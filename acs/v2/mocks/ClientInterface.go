// Code generated by mockery v2.9.5. DO NOT EDIT.

package mocks

import (
	context "context"
	http "net/http"

	io "io"

	mock "github.com/stretchr/testify/mock"

	v2 "github.com/splunk/terraform-provider-scp/acs/v2"
)

// ClientInterface is an autogenerated mock type for the ClientInterface type
type ClientInterface struct {
	mock.Mock
}

// AddLimitConfig provides a mock function with given fields: ctx, stack, stanza, body, reqEditors
func (_m *ClientInterface) AddLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, body v2.AddLimitConfigJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.AddLimitConfigJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.AddLimitConfigJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddLimitConfigWithBody provides a mock function with given fields: ctx, stack, stanza, contentType, body, reqEditors
func (_m *ClientInterface) AddLimitConfigWithBody(ctx context.Context, stack v2.Stack, stanza v2.Stanza, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddOutboundports provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) AddOutboundports(ctx context.Context, stack v2.Stack, body v2.AddOutboundportsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AddOutboundportsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AddOutboundportsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddOutboundportsWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) AddOutboundportsWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSubnets provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) AddSubnets(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.AddSubnetsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.AddSubnetsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.AddSubnetsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSubnetsWithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) AddSubnetsWithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuditMaintenanceWindowsSchedule provides a mock function with given fields: ctx, stack, scheduleID, params, reqEditors
func (_m *ClientInterface) AuditMaintenanceWindowsSchedule(ctx context.Context, stack v2.Stack, scheduleID v2.ScheduleID, params *v2.AuditMaintenanceWindowsScheduleParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, scheduleID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, *v2.AuditMaintenanceWindowsScheduleParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, scheduleID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.ScheduleID, *v2.AuditMaintenanceWindowsScheduleParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, scheduleID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHEC provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateHEC(ctx context.Context, stack v2.Stack, body v2.CreateHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHECWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateHECWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIndex provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateIndex(ctx context.Context, stack v2.Stack, body v2.CreateIndexJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateIndexJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateIndexJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIndexWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateIndexWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRole provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) CreateRole(ctx context.Context, stack v2.Stack, params *v2.CreateRoleParams, body v2.CreateRoleJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, v2.CreateRoleJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateRoleParams, v2.CreateRoleJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRoleWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) CreateRoleWithBody(ctx context.Context, stack v2.Stack, params *v2.CreateRoleParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateRoleParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSelfStorageLocation provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateSelfStorageLocation(ctx context.Context, stack v2.Stack, body v2.CreateSelfStorageLocationJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateSelfStorageLocationJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateSelfStorageLocationJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSelfStorageLocationWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateSelfStorageLocationWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateToken provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateToken(ctx context.Context, stack v2.Stack, body v2.CreateTokenJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateTokenJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateTokenJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTokenWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateTokenWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) CreateUser(ctx context.Context, stack v2.Stack, params *v2.CreateUserParams, body v2.CreateUserJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, v2.CreateUserJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateUserParams, v2.CreateUserJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) CreateUserWithBody(ctx context.Context, stack v2.Stack, params *v2.CreateUserParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateUserParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHec provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) DeleteHec(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.DeleteHecJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.DeleteHecJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.DeleteHecJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHecWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) DeleteHecWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIndex provides a mock function with given fields: ctx, stack, index, body, reqEditors
func (_m *ClientInterface) DeleteIndex(ctx context.Context, stack v2.Stack, index v2.Index, body v2.DeleteIndexJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.DeleteIndexJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, v2.DeleteIndexJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIndexWithBody provides a mock function with given fields: ctx, stack, index, contentType, body, reqEditors
func (_m *ClientInterface) DeleteIndexWithBody(ctx context.Context, stack v2.Stack, index v2.Index, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundport provides a mock function with given fields: ctx, stack, port, body, reqEditors
func (_m *ClientInterface) DeleteOutboundport(ctx context.Context, stack v2.Stack, port int32, body v2.DeleteOutboundportJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundportJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundportJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundportWithBody provides a mock function with given fields: ctx, stack, port, contentType, body, reqEditors
func (_m *ClientInterface) DeleteOutboundportWithBody(ctx context.Context, stack v2.Stack, port int32, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRole provides a mock function with given fields: ctx, stack, roleName, reqEditors
func (_m *ClientInterface) DeleteRole(ctx context.Context, stack v2.Stack, roleName v2.RoleName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnet provides a mock function with given fields: ctx, stack, feature, subnet, reqEditors
func (_m *ClientInterface) DeleteSubnet(ctx context.Context, stack v2.Stack, feature v2.Feature, subnet string, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, subnet)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnets provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) DeleteSubnets(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.DeleteSubnetsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteSubnetsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteSubnetsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetsWithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) DeleteSubnetsWithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteToken provides a mock function with given fields: ctx, stack, tokenID, reqEditors
func (_m *ClientInterface) DeleteToken(ctx context.Context, stack v2.Stack, tokenID v2.TokenID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, tokenID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, stack, userName, reqEditors
func (_m *ClientInterface) DeleteUser(ctx context.Context, stack v2.Stack, userName v2.UserName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAllowlist provides a mock function with given fields: ctx, stack, feature, reqEditors
func (_m *ClientInterface) DescribeAllowlist(ctx context.Context, stack v2.Stack, feature v2.Feature, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeApp provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) DescribeApp(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAppFeatureEnablement provides a mock function with given fields: ctx, stack, appGroup, featureName, reqEditors
func (_m *ClientInterface) DescribeAppFeatureEnablement(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAppVictoria provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) DescribeAppVictoria(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHec provides a mock function with given fields: ctx, stack, hec, reqEditors
func (_m *ClientInterface) DescribeHec(ctx context.Context, stack v2.Stack, hec v2.Hec, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMaintenanceWindowsSchedule provides a mock function with given fields: ctx, stack, scheduleID, reqEditors
func (_m *ClientInterface) DescribeMaintenanceWindowsSchedule(ctx context.Context, stack v2.Stack, scheduleID v2.ScheduleID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, scheduleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, scheduleID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.ScheduleID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, scheduleID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutboundports provides a mock function with given fields: ctx, stack, port, reqEditors
func (_m *ClientInterface) DescribeOutboundports(ctx context.Context, stack v2.Stack, port int32, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrivateConnectivity provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribePrivateConnectivity(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRole provides a mock function with given fields: ctx, stack, roleName, reqEditors
func (_m *ClientInterface) DescribeRole(ctx context.Context, stack v2.Stack, roleName v2.RoleName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSelfStorageLocation provides a mock function with given fields: ctx, stack, bucketPath, reqEditors
func (_m *ClientInterface) DescribeSelfStorageLocation(ctx context.Context, stack v2.Stack, bucketPath v2.BucketPath, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, bucketPath)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketPath, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, bucketPath, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.BucketPath, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, bucketPath, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStack provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribeStack(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUser provides a mock function with given fields: ctx, stack, userName, reqEditors
func (_m *ClientInterface) DescribeUser(ctx context.Context, stack v2.Stack, userName v2.UserName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnablePrivateConnectivity provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) EnablePrivateConnectivity(ctx context.Context, stack v2.Stack, body v2.EnablePrivateConnectivityJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.EnablePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.EnablePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnablePrivateConnectivityWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) EnablePrivateConnectivityWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllLimitsConfig provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetAllLimitsConfig(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllLimitsConfigDefaults provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetAllLimitsConfigDefaults(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIndexInfo provides a mock function with given fields: ctx, stack, index, reqEditors
func (_m *ClientInterface) GetIndexInfo(ctx context.Context, stack v2.Stack, index v2.Index, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyLimitConfig provides a mock function with given fields: ctx, stack, stanza, key, reqEditors
func (_m *ClientInterface) GetKeyLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, key v2.Key, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.Key, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, key, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.Key, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, key, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLimitConfig provides a mock function with given fields: ctx, stack, stanza, reqEditors
func (_m *ClientInterface) GetLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLimitsConfigDefaults provides a mock function with given fields: ctx, stack, stanza, reqEditors
func (_m *ClientInterface) GetLimitsConfigDefaults(ctx context.Context, stack v2.Stack, stanza v2.Stanza, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutboundports provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetOutboundports(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationPolicy provides a mock function with given fields: ctx, stack, bucketName, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationPolicy(ctx context.Context, stack v2.Stack, bucketName v2.BucketName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, bucketName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, bucketName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.BucketName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, bucketName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationPrefix provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationPrefix(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationServiceAccounts provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationServiceAccounts(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenInfo provides a mock function with given fields: ctx, stack, tokenID, reqEditors
func (_m *ClientInterface) GetTokenInfo(ctx context.Context, stack v2.Stack, tokenID v2.TokenID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, tokenID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallAppVictoriaWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) InstallAppVictoriaWithBody(ctx context.Context, stack v2.Stack, params *v2.InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.InstallAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallAppWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) InstallAppWithBody(ctx context.Context, stack v2.Stack, params *v2.InstallAppParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.InstallAppParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApps provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListApps(ctx context.Context, stack v2.Stack, params *v2.ListAppsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListAppsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAppsVictoria provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListAppsVictoria(ctx context.Context, stack v2.Stack, params *v2.ListAppsVictoriaParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsVictoriaParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListAppsVictoriaParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCapabilities provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListCapabilities(ctx context.Context, stack v2.Stack, params *v2.ListCapabilitiesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListCapabilitiesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListCapabilitiesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHECs provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListHECs(ctx context.Context, stack v2.Stack, params *v2.ListHECsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListHECsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListHECsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIndexes provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListIndexes(ctx context.Context, stack v2.Stack, params *v2.ListIndexesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListIndexesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListIndexesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMaintenanceWindowsSchedules provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListMaintenanceWindowsSchedules(ctx context.Context, stack v2.Stack, params *v2.ListMaintenanceWindowsSchedulesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListMaintenanceWindowsSchedulesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListMaintenanceWindowsSchedulesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRoles provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListRoles(ctx context.Context, stack v2.Stack, params *v2.ListRolesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListRolesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListRolesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSelfStorageLocations provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListSelfStorageLocations(ctx context.Context, stack v2.Stack, params *v2.ListSelfStorageLocationsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListSelfStorageLocationsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListSelfStorageLocationsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTokens provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListTokens(ctx context.Context, stack v2.Stack, params *v2.ListTokensParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListTokensParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListTokensParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListUsers(ctx context.Context, stack v2.Stack, params *v2.ListUsersParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListUsersParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListUsersParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchAppClassicWithBody provides a mock function with given fields: ctx, stack, app, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchAppClassicWithBody(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppClassicParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppClassicParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchAppVictoriaWithBody provides a mock function with given fields: ctx, stack, app, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchAppVictoriaWithBody(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchHEC provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) PatchHEC(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.PatchHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.PatchHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.PatchHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchHECWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) PatchHECWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchIndexInfo provides a mock function with given fields: ctx, stack, index, body, reqEditors
func (_m *ClientInterface) PatchIndexInfo(ctx context.Context, stack v2.Stack, index v2.Index, body v2.PatchIndexInfoJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.PatchIndexInfoJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, v2.PatchIndexInfoJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchIndexInfoWithBody provides a mock function with given fields: ctx, stack, index, contentType, body, reqEditors
func (_m *ClientInterface) PatchIndexInfoWithBody(ctx context.Context, stack v2.Stack, index v2.Index, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchRoleInfo provides a mock function with given fields: ctx, stack, roleName, params, body, reqEditors
func (_m *ClientInterface) PatchRoleInfo(ctx context.Context, stack v2.Stack, roleName v2.RoleName, params *v2.PatchRoleInfoParams, body v2.PatchRoleInfoJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, v2.PatchRoleInfoJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, v2.PatchRoleInfoJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchRoleInfoWithBody provides a mock function with given fields: ctx, stack, roleName, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchRoleInfoWithBody(ctx context.Context, stack v2.Stack, roleName v2.RoleName, params *v2.PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchUser provides a mock function with given fields: ctx, stack, userName, params, body, reqEditors
func (_m *ClientInterface) PatchUser(ctx context.Context, stack v2.Stack, userName v2.UserName, params *v2.PatchUserParams, body v2.PatchUserJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, v2.PatchUserJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, v2.PatchUserJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchUserWithBody provides a mock function with given fields: ctx, stack, userName, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchUserWithBody(ctx context.Context, stack v2.Stack, userName v2.UserName, params *v2.PatchUserParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetLimitConfig provides a mock function with given fields: ctx, stack, stanza, body, reqEditors
func (_m *ClientInterface) ResetLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, body v2.ResetLimitConfigJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.ResetLimitConfigJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.ResetLimitConfigJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetLimitConfigWithBody provides a mock function with given fields: ctx, stack, stanza, contentType, body, reqEditors
func (_m *ClientInterface) ResetLimitConfigWithBody(ctx context.Context, stack v2.Stack, stanza v2.Stanza, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartStack provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) RestartStack(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartStatus provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) RestartStatus(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAppFeatureEnablement provides a mock function with given fields: ctx, stack, appGroup, featureName, body, reqEditors
func (_m *ClientInterface) SetAppFeatureEnablement(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, body v2.SetAppFeatureEnablementJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, v2.SetAppFeatureEnablementJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, v2.SetAppFeatureEnablementJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAppFeatureEnablementWithBody provides a mock function with given fields: ctx, stack, appGroup, featureName, contentType, body, reqEditors
func (_m *ClientInterface) SetAppFeatureEnablementWithBody(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UninstallApp provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) UninstallApp(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UninstallAppVictoria provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) UninstallAppVictoria(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHEC provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) UpdateHEC(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.UpdateHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.UpdateHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.UpdateHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHECWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) UpdateHECWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrivateConnectivity provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) UpdatePrivateConnectivity(ctx context.Context, stack v2.Stack, body v2.UpdatePrivateConnectivityJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdatePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UpdatePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrivateConnectivityWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) UpdatePrivateConnectivityWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePrivateConnectivity provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) ValidatePrivateConnectivity(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *http.Response
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
