// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"
	http "net/http"

	io "io"

	mock "github.com/stretchr/testify/mock"

	v2 "github.com/splunk/terraform-provider-scp/acs/v2"
)

// ClientInterface is an autogenerated mock type for the ClientInterface type
type ClientInterface struct {
	mock.Mock
}

// AddLimitConfig provides a mock function with given fields: ctx, stack, stanza, body, reqEditors
func (_m *ClientInterface) AddLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, body v2.AddLimitConfigJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddLimitConfig")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.AddLimitConfigJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.AddLimitConfigJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.AddLimitConfigJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddLimitConfigWithBody provides a mock function with given fields: ctx, stack, stanza, contentType, body, reqEditors
func (_m *ClientInterface) AddLimitConfigWithBody(ctx context.Context, stack v2.Stack, stanza v2.Stanza, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddLimitConfigWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddOutboundports provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) AddOutboundports(ctx context.Context, stack v2.Stack, body v2.AddOutboundportsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddOutboundports")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AddOutboundportsJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AddOutboundportsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AddOutboundportsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddOutboundportsWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) AddOutboundportsWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddOutboundportsWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSubnets provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) AddSubnets(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.AddSubnetsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSubnets")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.AddSubnetsJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.AddSubnetsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.AddSubnetsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSubnetsWithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) AddSubnetsWithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSubnetsWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuditMaintenanceWindowsSchedule provides a mock function with given fields: ctx, stack, scheduleID, params, reqEditors
func (_m *ClientInterface) AuditMaintenanceWindowsSchedule(ctx context.Context, stack v2.Stack, scheduleID v2.ScheduleID, params *v2.AuditMaintenanceWindowsScheduleParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, scheduleID, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuditMaintenanceWindowsSchedule")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, *v2.AuditMaintenanceWindowsScheduleParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, scheduleID, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, *v2.AuditMaintenanceWindowsScheduleParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, scheduleID, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.ScheduleID, *v2.AuditMaintenanceWindowsScheduleParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, scheduleID, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangePythonVersion provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) ChangePythonVersion(ctx context.Context, stack v2.Stack, body v2.ChangePythonVersionJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangePythonVersion")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ChangePythonVersionJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ChangePythonVersionJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.ChangePythonVersionJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangePythonVersionWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) ChangePythonVersionWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangePythonVersionWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAllowlistV6 provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) CreateAllowlistV6(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.CreateAllowlistV6JSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAllowlistV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.CreateAllowlistV6JSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.CreateAllowlistV6JSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.CreateAllowlistV6JSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAllowlistV6WithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) CreateAllowlistV6WithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAllowlistV6WithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHEC provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateHEC(ctx context.Context, stack v2.Stack, body v2.CreateHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHEC")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateHECJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateHECWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateHECWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateHECWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIndex provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateIndex(ctx context.Context, stack v2.Stack, body v2.CreateIndexJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIndex")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateIndexJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateIndexJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateIndexJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIndexWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateIndexWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIndexWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOutboundPortsV6 provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateOutboundPortsV6(ctx context.Context, stack v2.Stack, body v2.CreateOutboundPortsV6JSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateOutboundPortsV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateOutboundPortsV6JSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateOutboundPortsV6JSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateOutboundPortsV6JSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOutboundPortsV6WithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateOutboundPortsV6WithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateOutboundPortsV6WithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRole provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) CreateRole(ctx context.Context, stack v2.Stack, params *v2.CreateRoleParams, body v2.CreateRoleJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRole")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, v2.CreateRoleJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, v2.CreateRoleJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateRoleParams, v2.CreateRoleJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRoleWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) CreateRoleWithBody(ctx context.Context, stack v2.Stack, params *v2.CreateRoleParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRoleWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateRoleParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateRoleParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSelfStorageLocation provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateSelfStorageLocation(ctx context.Context, stack v2.Stack, body v2.CreateSelfStorageLocationJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSelfStorageLocation")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateSelfStorageLocationJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateSelfStorageLocationJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateSelfStorageLocationJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSelfStorageLocationWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateSelfStorageLocationWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSelfStorageLocationWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateToken provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) CreateToken(ctx context.Context, stack v2.Stack, body v2.CreateTokenJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateToken")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateTokenJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.CreateTokenJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.CreateTokenJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTokenWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) CreateTokenWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTokenWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) CreateUser(ctx context.Context, stack v2.Stack, params *v2.CreateUserParams, body v2.CreateUserJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, v2.CreateUserJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, v2.CreateUserJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateUserParams, v2.CreateUserJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) CreateUserWithBody(ctx context.Context, stack v2.Stack, params *v2.CreateUserParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.CreateUserParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.CreateUserParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllowlistV6 provides a mock function with given fields: ctx, stack, feature, subnet, reqEditors
func (_m *ClientInterface) DeleteAllowlistV6(ctx context.Context, stack v2.Stack, feature v2.Feature, subnet string, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, subnet)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllowlistV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, subnet, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllowlistsV6 provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) DeleteAllowlistsV6(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.DeleteAllowlistsV6JSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllowlistsV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteAllowlistsV6JSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteAllowlistsV6JSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteAllowlistsV6JSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllowlistsV6WithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) DeleteAllowlistsV6WithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllowlistsV6WithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHec provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) DeleteHec(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.DeleteHecJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHec")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.DeleteHecJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.DeleteHecJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.DeleteHecJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteHecWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) DeleteHecWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHecWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIndex provides a mock function with given fields: ctx, stack, index, body, reqEditors
func (_m *ClientInterface) DeleteIndex(ctx context.Context, stack v2.Stack, index v2.Index, body v2.DeleteIndexJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIndex")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.DeleteIndexJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, index, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.DeleteIndexJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, v2.DeleteIndexJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteIndexWithBody provides a mock function with given fields: ctx, stack, index, contentType, body, reqEditors
func (_m *ClientInterface) DeleteIndexWithBody(ctx context.Context, stack v2.Stack, index v2.Index, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIndexWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, index, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundPortV6 provides a mock function with given fields: ctx, stack, port, body, reqEditors
func (_m *ClientInterface) DeleteOutboundPortV6(ctx context.Context, stack v2.Stack, port int32, body v2.DeleteOutboundPortV6JSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundPortV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundPortV6JSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundPortV6JSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundPortV6JSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundPortV6WithBody provides a mock function with given fields: ctx, stack, port, contentType, body, reqEditors
func (_m *ClientInterface) DeleteOutboundPortV6WithBody(ctx context.Context, stack v2.Stack, port int32, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundPortV6WithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundport provides a mock function with given fields: ctx, stack, port, body, reqEditors
func (_m *ClientInterface) DeleteOutboundport(ctx context.Context, stack v2.Stack, port int32, body v2.DeleteOutboundportJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundport")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundportJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundportJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, v2.DeleteOutboundportJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteOutboundportWithBody provides a mock function with given fields: ctx, stack, port, contentType, body, reqEditors
func (_m *ClientInterface) DeleteOutboundportWithBody(ctx context.Context, stack v2.Stack, port int32, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOutboundportWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRole provides a mock function with given fields: ctx, stack, roleName, reqEditors
func (_m *ClientInterface) DeleteRole(ctx context.Context, stack v2.Stack, roleName v2.RoleName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRole")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, roleName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnet provides a mock function with given fields: ctx, stack, feature, subnet, reqEditors
func (_m *ClientInterface) DeleteSubnet(ctx context.Context, stack v2.Stack, feature v2.Feature, subnet string, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, subnet)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnet")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, subnet, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, subnet, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnets provides a mock function with given fields: ctx, stack, feature, body, reqEditors
func (_m *ClientInterface) DeleteSubnets(ctx context.Context, stack v2.Stack, feature v2.Feature, body v2.DeleteSubnetsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnets")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteSubnetsJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteSubnetsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, v2.DeleteSubnetsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSubnetsWithBody provides a mock function with given fields: ctx, stack, feature, contentType, body, reqEditors
func (_m *ClientInterface) DeleteSubnetsWithBody(ctx context.Context, stack v2.Stack, feature v2.Feature, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubnetsWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteToken provides a mock function with given fields: ctx, stack, tokenID, reqEditors
func (_m *ClientInterface) DeleteToken(ctx context.Context, stack v2.Stack, tokenID v2.TokenID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, tokenID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteToken")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, tokenID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUser provides a mock function with given fields: ctx, stack, userName, reqEditors
func (_m *ClientInterface) DeleteUser(ctx context.Context, stack v2.Stack, userName v2.UserName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, userName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAllowlist provides a mock function with given fields: ctx, stack, feature, reqEditors
func (_m *ClientInterface) DescribeAllowlist(ctx context.Context, stack v2.Stack, feature v2.Feature, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAllowlist")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAllowlistV6 provides a mock function with given fields: ctx, stack, feature, reqEditors
func (_m *ClientInterface) DescribeAllowlistV6(ctx context.Context, stack v2.Stack, feature v2.Feature, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, feature)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAllowlistV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, feature, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, feature, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Feature, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, feature, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeApp provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) DescribeApp(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeApp")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAppFeatureEnablement provides a mock function with given fields: ctx, stack, appGroup, featureName, reqEditors
func (_m *ClientInterface) DescribeAppFeatureEnablement(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAppFeatureEnablement")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, appGroup, featureName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeAppVictoria provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) DescribeAppVictoria(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAppVictoria")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDeployment provides a mock function with given fields: ctx, stack, deploymentID, reqEditors
func (_m *ClientInterface) DescribeDeployment(ctx context.Context, stack v2.Stack, deploymentID v2.DeploymentID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, deploymentID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDeployment")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.DeploymentID, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, deploymentID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.DeploymentID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, deploymentID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.DeploymentID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, deploymentID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeEmekWaiver provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribeEmekWaiver(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeEmekWaiver")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeHec provides a mock function with given fields: ctx, stack, hec, reqEditors
func (_m *ClientInterface) DescribeHec(ctx context.Context, stack v2.Stack, hec v2.Hec, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeHec")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMaintenanceWindowsPreferences provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribeMaintenanceWindowsPreferences(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMaintenanceWindowsPreferences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeMaintenanceWindowsSchedule provides a mock function with given fields: ctx, stack, scheduleID, reqEditors
func (_m *ClientInterface) DescribeMaintenanceWindowsSchedule(ctx context.Context, stack v2.Stack, scheduleID v2.ScheduleID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, scheduleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeMaintenanceWindowsSchedule")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, scheduleID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.ScheduleID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, scheduleID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.ScheduleID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, scheduleID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeManagedGlueResources provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribeManagedGlueResources(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeManagedGlueResources")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutboundports provides a mock function with given fields: ctx, stack, port, reqEditors
func (_m *ClientInterface) DescribeOutboundports(ctx context.Context, stack v2.Stack, port int32, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOutboundports")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeOutboundportsV6 provides a mock function with given fields: ctx, stack, port, reqEditors
func (_m *ClientInterface) DescribeOutboundportsV6(ctx context.Context, stack v2.Stack, port int32, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, port)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeOutboundportsV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, port, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, port, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, int32, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, port, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePermissionsApps provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) DescribePermissionsApps(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePermissionsApps")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribePrivateConnectivity provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) DescribePrivateConnectivity(ctx context.Context, stack v2.Stack, params *v2.DescribePrivateConnectivityParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribePrivateConnectivity")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.DescribePrivateConnectivityParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.DescribePrivateConnectivityParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.DescribePrivateConnectivityParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeRole provides a mock function with given fields: ctx, stack, roleName, reqEditors
func (_m *ClientInterface) DescribeRole(ctx context.Context, stack v2.Stack, roleName v2.RoleName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeRole")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, roleName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeSelfStorageLocation provides a mock function with given fields: ctx, stack, bucketPath, reqEditors
func (_m *ClientInterface) DescribeSelfStorageLocation(ctx context.Context, stack v2.Stack, bucketPath v2.BucketPath, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, bucketPath)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSelfStorageLocation")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketPath, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, bucketPath, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketPath, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, bucketPath, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.BucketPath, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, bucketPath, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeStack provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) DescribeStack(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeStack")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUser provides a mock function with given fields: ctx, stack, userName, reqEditors
func (_m *ClientInterface) DescribeUser(ctx context.Context, stack v2.Stack, userName v2.UserName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, userName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeWorkflow provides a mock function with given fields: ctx, stack, workflowName, reqEditors
func (_m *ClientInterface) DescribeWorkflow(ctx context.Context, stack v2.Stack, workflowName v2.WorkflowName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, workflowName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorkflow")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.WorkflowName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, workflowName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.WorkflowName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, workflowName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.WorkflowName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, workflowName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DownloadAppExportVictoria provides a mock function with given fields: ctx, stack, app, params, reqEditors
func (_m *ClientInterface) DownloadAppExportVictoria(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.DownloadAppExportVictoriaParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DownloadAppExportVictoria")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.DownloadAppExportVictoriaParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.DownloadAppExportVictoriaParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.DownloadAppExportVictoriaParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnablePrivateConnectivity provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) EnablePrivateConnectivity(ctx context.Context, stack v2.Stack, body v2.EnablePrivateConnectivityJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnablePrivateConnectivity")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.EnablePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.EnablePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.EnablePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnablePrivateConnectivityWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) EnablePrivateConnectivityWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnablePrivateConnectivityWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableRbacOnO11y provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) EnableRbacOnO11y(ctx context.Context, stack string, params *v2.EnableRbacOnO11yParams, body v2.EnableRbacOnO11yJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableRbacOnO11y")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.EnableRbacOnO11yParams, v2.EnableRbacOnO11yJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.EnableRbacOnO11yParams, v2.EnableRbacOnO11yJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *v2.EnableRbacOnO11yParams, v2.EnableRbacOnO11yJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnableRbacOnO11yWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) EnableRbacOnO11yWithBody(ctx context.Context, stack string, params *v2.EnableRbacOnO11yParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableRbacOnO11yWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.EnableRbacOnO11yParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.EnableRbacOnO11yParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *v2.EnableRbacOnO11yParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllLimitsConfig provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetAllLimitsConfig(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllLimitsConfig")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllLimitsConfigDefaults provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetAllLimitsConfigDefaults(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllLimitsConfigDefaults")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEmekPolicy provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) GetEmekPolicy(ctx context.Context, stack v2.Stack, params *v2.GetEmekPolicyParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEmekPolicy")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.GetEmekPolicyParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.GetEmekPolicyParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.GetEmekPolicyParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIndexInfo provides a mock function with given fields: ctx, stack, index, reqEditors
func (_m *ClientInterface) GetIndexInfo(ctx context.Context, stack v2.Stack, index v2.Index, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexInfo")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, index, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyLimitConfig provides a mock function with given fields: ctx, stack, stanza, key, reqEditors
func (_m *ClientInterface) GetKeyLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, key v2.Key, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetKeyLimitConfig")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.Key, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, key, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.Key, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, key, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.Key, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, key, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLimitConfig provides a mock function with given fields: ctx, stack, stanza, reqEditors
func (_m *ClientInterface) GetLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLimitConfig")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLimitsConfigDefaults provides a mock function with given fields: ctx, stack, stanza, reqEditors
func (_m *ClientInterface) GetLimitsConfigDefaults(ctx context.Context, stack v2.Stack, stanza v2.Stanza, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLimitsConfigDefaults")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetObservabilityPairingStatus provides a mock function with given fields: ctx, stack, pairingId, params, reqEditors
func (_m *ClientInterface) GetObservabilityPairingStatus(ctx context.Context, stack string, pairingId string, params *v2.GetObservabilityPairingStatusParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, pairingId, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetObservabilityPairingStatus")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *v2.GetObservabilityPairingStatusParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, pairingId, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *v2.GetObservabilityPairingStatusParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, pairingId, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *v2.GetObservabilityPairingStatusParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, pairingId, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOutboundports provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetOutboundports(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOutboundports")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPythonVersion provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetPythonVersion(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPythonVersion")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationPolicy provides a mock function with given fields: ctx, stack, bucketName, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationPolicy(ctx context.Context, stack v2.Stack, bucketName v2.BucketName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, bucketName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSelfStorageLocationPolicy")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, bucketName, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.BucketName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, bucketName, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.BucketName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, bucketName, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationPrefix provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationPrefix(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSelfStorageLocationPrefix")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSelfStorageLocationServiceAccounts provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) GetSelfStorageLocationServiceAccounts(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSelfStorageLocationServiceAccounts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenInfo provides a mock function with given fields: ctx, stack, tokenID, reqEditors
func (_m *ClientInterface) GetTokenInfo(ctx context.Context, stack v2.Stack, tokenID v2.TokenID, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, tokenID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenInfo")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, tokenID, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.TokenID, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, tokenID, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallAppVictoriaWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) InstallAppVictoriaWithBody(ctx context.Context, stack v2.Stack, params *v2.InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InstallAppVictoriaWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.InstallAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallAppWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) InstallAppWithBody(ctx context.Context, stack v2.Stack, params *v2.InstallAppParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InstallAppWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.InstallAppParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.InstallAppParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListApps provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListApps(ctx context.Context, stack v2.Stack, params *v2.ListAppsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListApps")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListAppsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAppsVictoria provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListAppsVictoria(ctx context.Context, stack v2.Stack, params *v2.ListAppsVictoriaParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAppsVictoria")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsVictoriaParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListAppsVictoriaParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListAppsVictoriaParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCapabilities provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListCapabilities(ctx context.Context, stack v2.Stack, params *v2.ListCapabilitiesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCapabilities")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListCapabilitiesParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListCapabilitiesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListCapabilitiesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDeployment provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) ListDeployment(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDeployment")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHECs provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListHECs(ctx context.Context, stack v2.Stack, params *v2.ListHECsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListHECs")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListHECsParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListHECsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListHECsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIndexes provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListIndexes(ctx context.Context, stack v2.Stack, params *v2.ListIndexesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIndexes")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListIndexesParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListIndexesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListIndexesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMaintenanceWindowsSchedules provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListMaintenanceWindowsSchedules(ctx context.Context, stack v2.Stack, params *v2.ListMaintenanceWindowsSchedulesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMaintenanceWindowsSchedules")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListMaintenanceWindowsSchedulesParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListMaintenanceWindowsSchedulesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListMaintenanceWindowsSchedulesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOutboundPortsV6 provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) ListOutboundPortsV6(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListOutboundPortsV6")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPermissionsApps provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListPermissionsApps(ctx context.Context, stack v2.Stack, params *v2.ListPermissionsAppsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPermissionsApps")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListPermissionsAppsParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListPermissionsAppsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListPermissionsAppsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRoles provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListRoles(ctx context.Context, stack v2.Stack, params *v2.ListRolesParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRoles")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListRolesParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListRolesParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListRolesParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSelfStorageLocations provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListSelfStorageLocations(ctx context.Context, stack v2.Stack, params *v2.ListSelfStorageLocationsParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSelfStorageLocations")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListSelfStorageLocationsParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListSelfStorageLocationsParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListSelfStorageLocationsParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTokens provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListTokens(ctx context.Context, stack v2.Stack, params *v2.ListTokensParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTokens")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListTokensParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListTokensParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListTokensParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx, stack, params, reqEditors
func (_m *ClientInterface) ListUsers(ctx context.Context, stack v2.Stack, params *v2.ListUsersParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListUsersParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, *v2.ListUsersParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, *v2.ListUsersParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchAppClassicWithBody provides a mock function with given fields: ctx, stack, app, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchAppClassicWithBody(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchAppClassicWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppClassicParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppClassicParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppClassicParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchAppVictoriaWithBody provides a mock function with given fields: ctx, stack, app, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchAppVictoriaWithBody(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchAppVictoriaWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.PatchAppVictoriaParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchHEC provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) PatchHEC(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.PatchHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchHEC")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.PatchHECJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.PatchHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.PatchHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchHECWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) PatchHECWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchHECWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchIndexInfo provides a mock function with given fields: ctx, stack, index, body, reqEditors
func (_m *ClientInterface) PatchIndexInfo(ctx context.Context, stack v2.Stack, index v2.Index, body v2.PatchIndexInfoJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchIndexInfo")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.PatchIndexInfoJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, index, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, v2.PatchIndexInfoJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, v2.PatchIndexInfoJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchIndexInfoWithBody provides a mock function with given fields: ctx, stack, index, contentType, body, reqEditors
func (_m *ClientInterface) PatchIndexInfoWithBody(ctx context.Context, stack v2.Stack, index v2.Index, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, index, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchIndexInfoWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, index, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Index, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, index, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchPermissionsApps provides a mock function with given fields: ctx, stack, app, body, reqEditors
func (_m *ClientInterface) PatchPermissionsApps(ctx context.Context, stack v2.Stack, app v2.AppName, body v2.PatchPermissionsAppsJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchPermissionsApps")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, v2.PatchPermissionsAppsJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, v2.PatchPermissionsAppsJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, v2.PatchPermissionsAppsJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchPermissionsAppsWithBody provides a mock function with given fields: ctx, stack, app, contentType, body, reqEditors
func (_m *ClientInterface) PatchPermissionsAppsWithBody(ctx context.Context, stack v2.Stack, app v2.AppName, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchPermissionsAppsWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchRoleInfo provides a mock function with given fields: ctx, stack, roleName, params, body, reqEditors
func (_m *ClientInterface) PatchRoleInfo(ctx context.Context, stack v2.Stack, roleName v2.RoleName, params *v2.PatchRoleInfoParams, body v2.PatchRoleInfoJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchRoleInfo")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, v2.PatchRoleInfoJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, roleName, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, v2.PatchRoleInfoJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, v2.PatchRoleInfoJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchRoleInfoWithBody provides a mock function with given fields: ctx, stack, roleName, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchRoleInfoWithBody(ctx context.Context, stack v2.Stack, roleName v2.RoleName, params *v2.PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, roleName, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchRoleInfoWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, roleName, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, roleName, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.RoleName, *v2.PatchRoleInfoParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, roleName, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchUser provides a mock function with given fields: ctx, stack, userName, params, body, reqEditors
func (_m *ClientInterface) PatchUser(ctx context.Context, stack v2.Stack, userName v2.UserName, params *v2.PatchUserParams, body v2.PatchUserJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, v2.PatchUserJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, userName, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, v2.PatchUserJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, v2.PatchUserJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchUserWithBody provides a mock function with given fields: ctx, stack, userName, params, contentType, body, reqEditors
func (_m *ClientInterface) PatchUserWithBody(ctx context.Context, stack v2.Stack, userName v2.UserName, params *v2.PatchUserParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, userName, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PatchUserWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, userName, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, userName, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UserName, *v2.PatchUserParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, userName, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostObservabilityCapabilitiesOnSplunk provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) PostObservabilityCapabilitiesOnSplunk(ctx context.Context, stack string, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostObservabilityCapabilitiesOnSplunk")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostObservabilityPairing provides a mock function with given fields: ctx, stack, params, body, reqEditors
func (_m *ClientInterface) PostObservabilityPairing(ctx context.Context, stack string, params *v2.PostObservabilityPairingParams, body v2.PostObservabilityPairingJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostObservabilityPairing")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.PostObservabilityPairingParams, v2.PostObservabilityPairingJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.PostObservabilityPairingParams, v2.PostObservabilityPairingJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *v2.PostObservabilityPairingParams, v2.PostObservabilityPairingJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostObservabilityPairingWithBody provides a mock function with given fields: ctx, stack, params, contentType, body, reqEditors
func (_m *ClientInterface) PostObservabilityPairingWithBody(ctx context.Context, stack string, params *v2.PostObservabilityPairingParams, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, params, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostObservabilityPairingWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.PostObservabilityPairingParams, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, params, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *v2.PostObservabilityPairingParams, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *v2.PostObservabilityPairingParams, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, params, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutEmekKey provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) PutEmekKey(ctx context.Context, stack v2.Stack, body v2.PutEmekKeyJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEmekKey")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.PutEmekKeyJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.PutEmekKeyJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.PutEmekKeyJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutEmekKeyWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) PutEmekKeyWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PutEmekKeyWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetLimitConfig provides a mock function with given fields: ctx, stack, stanza, body, reqEditors
func (_m *ClientInterface) ResetLimitConfig(ctx context.Context, stack v2.Stack, stanza v2.Stanza, body v2.ResetLimitConfigJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetLimitConfig")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.ResetLimitConfigJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, v2.ResetLimitConfigJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, v2.ResetLimitConfigJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetLimitConfigWithBody provides a mock function with given fields: ctx, stack, stanza, contentType, body, reqEditors
func (_m *ClientInterface) ResetLimitConfigWithBody(ctx context.Context, stack v2.Stack, stanza v2.Stanza, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, stanza, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetLimitConfigWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, stanza, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Stanza, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, stanza, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartStack provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) RestartStack(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestartStack")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartStatus provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) RestartStatus(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestartStatus")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetryDeployment provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) RetryDeployment(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryDeployment")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAppFeatureEnablement provides a mock function with given fields: ctx, stack, appGroup, featureName, body, reqEditors
func (_m *ClientInterface) SetAppFeatureEnablement(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, body v2.SetAppFeatureEnablementJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetAppFeatureEnablement")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, v2.SetAppFeatureEnablementJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, appGroup, featureName, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, v2.SetAppFeatureEnablementJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, v2.SetAppFeatureEnablementJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAppFeatureEnablementWithBody provides a mock function with given fields: ctx, stack, appGroup, featureName, contentType, body, reqEditors
func (_m *ClientInterface) SetAppFeatureEnablementWithBody(ctx context.Context, stack v2.Stack, appGroup v2.AppGroup, featureName v2.FeatureName, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, appGroup, featureName, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetAppFeatureEnablementWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppGroup, v2.FeatureName, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UninstallApp provides a mock function with given fields: ctx, stack, app, reqEditors
func (_m *ClientInterface) UninstallApp(ctx context.Context, stack v2.Stack, app v2.AppName, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UninstallApp")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UninstallAppVictoria provides a mock function with given fields: ctx, stack, app, params, reqEditors
func (_m *ClientInterface) UninstallAppVictoria(ctx context.Context, stack v2.Stack, app v2.AppName, params *v2.UninstallAppVictoriaParams, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, app, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UninstallAppVictoria")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.UninstallAppVictoriaParams, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, app, params, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.AppName, *v2.UninstallAppVictoriaParams, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, app, params, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.AppName, *v2.UninstallAppVictoriaParams, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, app, params, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHEC provides a mock function with given fields: ctx, stack, hec, body, reqEditors
func (_m *ClientInterface) UpdateHEC(ctx context.Context, stack v2.Stack, hec v2.Hec, body v2.UpdateHECJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHEC")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.UpdateHECJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, v2.UpdateHECJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, v2.UpdateHECJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateHECWithBody provides a mock function with given fields: ctx, stack, hec, contentType, body, reqEditors
func (_m *ClientInterface) UpdateHECWithBody(ctx context.Context, stack v2.Stack, hec v2.Hec, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, hec, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHECWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, hec, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.Hec, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, hec, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMaintenanceWindowsPreferences provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) UpdateMaintenanceWindowsPreferences(ctx context.Context, stack v2.Stack, body v2.UpdateMaintenanceWindowsPreferencesJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMaintenanceWindowsPreferences")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdateMaintenanceWindowsPreferencesJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdateMaintenanceWindowsPreferencesJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UpdateMaintenanceWindowsPreferencesJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMaintenanceWindowsPreferencesWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) UpdateMaintenanceWindowsPreferencesWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMaintenanceWindowsPreferencesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateManagedGlueResources provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) UpdateManagedGlueResources(ctx context.Context, stack v2.Stack, body v2.UpdateManagedGlueResourcesJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateManagedGlueResources")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdateManagedGlueResourcesJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdateManagedGlueResourcesJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UpdateManagedGlueResourcesJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateManagedGlueResourcesWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) UpdateManagedGlueResourcesWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateManagedGlueResourcesWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrivateConnectivity provides a mock function with given fields: ctx, stack, body, reqEditors
func (_m *ClientInterface) UpdatePrivateConnectivity(ctx context.Context, stack v2.Stack, body v2.UpdatePrivateConnectivityJSONRequestBody, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrivateConnectivity")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdatePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, v2.UpdatePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, v2.UpdatePrivateConnectivityJSONRequestBody, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePrivateConnectivityWithBody provides a mock function with given fields: ctx, stack, contentType, body, reqEditors
func (_m *ClientInterface) UpdatePrivateConnectivityWithBody(ctx context.Context, stack v2.Stack, contentType string, body io.Reader, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrivateConnectivityWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, string, io.Reader, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatePrivateConnectivity provides a mock function with given fields: ctx, stack, reqEditors
func (_m *ClientInterface) ValidatePrivateConnectivity(ctx context.Context, stack v2.Stack, reqEditors ...v2.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stack)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ValidatePrivateConnectivity")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, stack, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, stack, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, v2.Stack, ...v2.RequestEditorFn) error); ok {
		r1 = rf(ctx, stack, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClientInterface creates a new instance of ClientInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClientInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ClientInterface {
	mock := &ClientInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
