// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package v2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
)

// an splunk installed on the stack
type App struct {
	AppID                      *string `json:"appID,omitempty"`
	Label                      *string `json:"label,omitempty"`
	Name                       string  `json:"name"`
	Package                    *string `json:"package,omitempty"`
	SplunkbaseID               *string `json:"splunkbaseID,omitempty"`
	StateChangeRequiresRestart *bool   `json:"stateChangeRequiresRestart,omitempty"`
	Status                     string  `json:"status"`
	Version                    *string `json:"version,omitempty"`
}

// AppFeatureEnablement defines model for AppFeatureEnablement.
type AppFeatureEnablement struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// App Permissions
type AppPerms struct {
	Name  string             `json:"name"`
	Perms AppPermsProperties `json:"perms"`
}

// AppPermsList defines model for AppPermsList.
type AppPermsList struct {
	Apps *[]AppPerms `json:"apps,omitempty"`
}

// AppPermsProperties defines model for AppPermsProperties.
type AppPermsProperties struct {
	Read  *[]string `json:"read,omitempty"`
	Write *[]string `json:"write,omitempty"`
}

// capabilities list
type CapabilitiesInfo struct {
	GrantableCapabilities *[]string `json:"grantableCapabilities,omitempty"`
	SystemCapabilities    *[]string `json:"systemCapabilities,omitempty"`
}

// Create user request body
type CreateUserRequest struct {
	CreateRole      *bool     `json:"createRole,omitempty"`
	DefaultApp      *string   `json:"defaultApp,omitempty"`
	Email           *string   `json:"email,omitempty"`
	ForceChangePass *bool     `json:"forceChangePass,omitempty"`
	FullName        *string   `json:"fullName,omitempty"`
	Name            string    `json:"name"`
	Password        string    `json:"password"`
	Roles           *[]string `json:"roles,omitempty"`
}

// DeploymentInfo defines model for DeploymentInfo.
type DeploymentInfo struct {

	// the id of the latest deployment task
	Id string `json:"id"`

	// the status of the last deployment task, possible values are new, completed, pending, running, failed.
	Status *string `json:"status,omitempty"`

	// timestamp of the latest deployment task
	Timestamp *string `json:"timestamp,omitempty"`
}

// DeploymentStatus defines model for DeploymentStatus.
type DeploymentStatus struct {
	LastDeployment DeploymentInfo `json:"lastDeployment"`
}

// DescribeEligibilityPrivateConnectivity defines model for DescribeEligibilityPrivateConnectivity.
type DescribeEligibilityPrivateConnectivity struct {
	Eligible *bool   `json:"eligible,omitempty"`
	Reason   *string `json:"reason,omitempty"`
}

// DescribePrivateConnectivity defines model for DescribePrivateConnectivity.
type DescribePrivateConnectivity struct {
	CustomerAccountIds *[]string `json:"customerAccountIds,omitempty"`
	Endpoint           *string   `json:"endpoint,omitempty"`
	Message            *string   `json:"message,omitempty"`
	Reason             *string   `json:"reason,omitempty"`
	Status             *string   `json:"status,omitempty"`
}

// EnablePrivateConnectivity defines model for EnablePrivateConnectivity.
type EnablePrivateConnectivity struct {
	CustomerAccountIds *[]string `json:"customerAccountIds,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// HecInfo defines model for HecInfo.
type HecInfo struct {
	Spec  *HecSpec `json:"spec,omitempty"`
	Token *string  `json:"token,omitempty"`
}

// HecSpec defines model for HecSpec.
type HecSpec struct {
	AllowedIndexes    *[]string `json:"allowedIndexes,omitempty"`
	DefaultHost       *string   `json:"defaultHost,omitempty"`
	DefaultIndex      *string   `json:"defaultIndex,omitempty"`
	DefaultSource     *string   `json:"defaultSource,omitempty"`
	DefaultSourcetype *string   `json:"defaultSourcetype,omitempty"`
	Disabled          *bool     `json:"disabled,omitempty"`
	Name              string    `json:"name"`
	Token             *string   `json:"token,omitempty"`
	UseAck            *bool     `json:"useAck,omitempty"`
}

// ImportedRolesInfo defines model for ImportedRolesInfo.
type ImportedRolesInfo struct {
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Roles *[]string `json:"roles,omitempty"`
}

// IndexInfo defines model for IndexInfo.
type IndexInfo struct {
	Datatype                    *string `json:"datatype,omitempty"`
	MaxDataSizeMB               *int64  `json:"maxDataSizeMB,omitempty"`
	Name                        string  `json:"name"`
	SearchableDays              *int64  `json:"searchableDays,omitempty"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *int64  `json:"splunkArchivalRetentionDays,omitempty"`
}

// IndexResponse defines model for IndexResponse.
type IndexResponse struct {
	Datatype                    string  `json:"datatype"`
	MaxDataSizeMB               uint64  `json:"maxDataSizeMB"`
	Name                        string  `json:"name"`
	SearchableDays              uint64  `json:"searchableDays"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *uint64 `json:"splunkArchivalRetentionDays,omitempty"`
	TotalEventCount             *string `json:"totalEventCount,omitempty"`
	TotalRawSizeMB              *string `json:"totalRawSizeMB,omitempty"`
}

// LimitConfigurationInfo defines model for LimitConfigurationInfo.
type LimitConfigurationInfo struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// LimitConfigurationResponse defines model for LimitConfigurationResponse.
type LimitConfigurationResponse struct {
	Settings *[]interface{} `json:"settings,omitempty"`
}

// LimitResetSettingsList defines model for LimitResetSettingsList.
type LimitResetSettingsList struct {
	Settings *[]interface{} `json:"settings,omitempty"`
}

// LimitSetting defines model for LimitSetting.
type LimitSetting struct {
	DefaultValue *float64 `json:"defaultValue,omitempty"`
	MaxValue     *float64 `json:"maxValue,omitempty"`
	MinValue     *float64 `json:"minValue,omitempty"`
	Setting      *string  `json:"setting,omitempty"`
}

// LimitStanza defines model for LimitStanza.
type LimitStanza struct {
	Settings *[]LimitSetting `json:"settings,omitempty"`
	Stanza   *string         `json:"stanza,omitempty"`
}

// MaintenanceWindowsAuditResponse defines model for MaintenanceWindowsAuditResponse.
type MaintenanceWindowsAuditResponse struct {
	Audits []MaintenanceWindowsSchedule `json:"audits"`
}

// MaintenanceWindowsOperation defines model for MaintenanceWindowsOperation.
type MaintenanceWindowsOperation struct {
	SFDCTickets *[]string `json:"SFDCTickets,omitempty"`

	// app name that needs to be upgraded
	AppName *string `json:"appName,omitempty"`

	// time at which the operation ended
	EndTime *time.Time `json:"endTime,omitempty"`

	// map containing metadata like target version, target instance, customerAckRequired, customerAckReceived etc.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// notes for splunk customer
	Notes *[]string `json:"notes,omitempty"`

	// description of the operation
	OperationDescription string `json:"operationDescription"`

	// maintenance window schedule operation status
	OperationStatus string `json:"operationStatus"`
	OperationType   string `json:"operationType"`

	// time at which the operation started
	StartTime *time.Time `json:"startTime,omitempty"`

	// target version after upgrade
	TargetVersion *string `json:"targetVersion,omitempty"`
}

// MaintenanceWindowsResponse defines model for MaintenanceWindowsResponse.
type MaintenanceWindowsResponse struct {
	NextLink  string                       `json:"nextLink"`
	Schedules []MaintenanceWindowsSchedule `json:"schedules"`
}

// MaintenanceWindowsSchedule defines model for MaintenanceWindowsSchedule.
type MaintenanceWindowsSchedule struct {

	// duration of maintenance windows in hours
	Duration              string    `json:"duration"`
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// summary or reason for the maintenance
	LastSummary *string `json:"lastSummary,omitempty"`

	// describes the type of upgrade falls under
	MwType     string                         `json:"mwType"`
	Operations *[]MaintenanceWindowsOperation `json:"operations,omitempty"`

	// requester of the maintenance, customer or splunk
	RequestedEntity string `json:"requestedEntity"`

	// user who is requesting the maintenance
	RequestedUser          *string   `json:"requestedUser,omitempty"`
	ScheduleId             string    `json:"scheduleId"`
	ScheduleStartTimestamp time.Time `json:"scheduleStartTimestamp"`

	// maintenance window schedule status
	Status string `json:"status"`
}

// OutboundResponse defines model for OutboundResponse.
type OutboundResponse struct {
	DestinationRanges *[]string `json:"destinationRanges,omitempty"`
	Name              *string   `json:"name,omitempty"`
	Port              *int32    `json:"port,omitempty"`
}

// patch permissions apps body
type PatchAppPermsRequest struct {
	Read  *[]string `json:"read,omitempty"`
	Write *[]string `json:"write,omitempty"`
}

// PatchIndexInfo defines model for PatchIndexInfo.
type PatchIndexInfo struct {
	MaxDataSizeMB               *int64  `json:"maxDataSizeMB,omitempty"`
	SearchableDays              *int64  `json:"searchableDays,omitempty"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *int64  `json:"splunkArchivalRetentionDays,omitempty"`
}

// the splunkbase app version to update.  If no version specified, the latest version will be installed.
type PatchSplunkbaseBody struct {
	Version *string `json:"version,omitempty"`
}

// Patch user request body
type PatchUserRequest struct {
	DefaultApp      *string   `json:"defaultApp,omitempty"`
	Email           *string   `json:"email,omitempty"`
	ForceChangePass *bool     `json:"forceChangePass,omitempty"`
	FullName        *string   `json:"fullName,omitempty"`
	OldPassword     *string   `json:"oldPassword,omitempty"`
	Password        *string   `json:"password,omitempty"`
	Roles           *[]string `json:"roles,omitempty"`
}

// PostRolesRequest defines model for PostRolesRequest.
type PostRolesRequest struct {
	// Embedded struct due to allOf(#/components/schemas/RolesRequest)
	RolesRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Name string `json:"name"`
}

// the app package in tgz format
type PrivateAppBody string

// RestartResponse defines model for RestartResponse.
type RestartResponse struct {
	Message *string `json:"message,omitempty"`
}

// RestartStatus defines model for RestartStatus.
type RestartStatus struct {
	Captain                 *string `json:"captain,omitempty"`
	RollingRestartInitiated *bool   `json:"rollingRestartInitiated,omitempty"`
	ServiceReady            *bool   `json:"serviceReady,omitempty"`
}

// RolesInfo defines model for RolesInfo.
type RolesInfo struct {
	Capabilities       *[]string `json:"capabilities,omitempty"`
	RtSrchJobsQuota    *int      `json:"rtSrchJobsQuota,omitempty"`
	SrchDiskQuota      *int      `json:"srchDiskQuota,omitempty"`
	SrchFilter         *string   `json:"srchFilter,omitempty"`
	SrchIndexesAllowed *[]string `json:"srchIndexesAllowed,omitempty"`
	SrchIndexesDefault *[]string `json:"srchIndexesDefault,omitempty"`
	SrchJobsQuota      *int      `json:"srchJobsQuota,omitempty"`
	SrchTimeEarliest   *int      `json:"srchTimeEarliest,omitempty"`
	SrchTimeWin        *int      `json:"srchTimeWin,omitempty"`
}

// RolesRequest defines model for RolesRequest.
type RolesRequest struct {
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	CumulativeRTSrchJobsQuota *int      `json:"cumulativeRTSrchJobsQuota,omitempty"`
	CumulativeSrchJobsQuota   *int      `json:"cumulativeSrchJobsQuota,omitempty"`
	DefaultApp                *string   `json:"defaultApp,omitempty"`
	ImportedRoles             *[]string `json:"importedRoles,omitempty"`
}

// RolesResponse defines model for RolesResponse.
type RolesResponse struct {
	// Embedded fields due to inline allOf schema
	CumulativeRTSrchJobsQuota *int               `json:"cumulativeRTSrchJobsQuota,omitempty"`
	CumulativeSrchJobsQuota   *int               `json:"cumulativeSrchJobsQuota,omitempty"`
	DefaultApp                *string            `json:"defaultApp,omitempty"`
	Imported                  *ImportedRolesInfo `json:"imported,omitempty"`
	Name                      string             `json:"name"`
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
}

// SelfStorageLocationBody defines model for SelfStorageLocationBody.
type SelfStorageLocationBody struct {
	BucketName  string  `json:"bucketName"`
	Description *string `json:"description,omitempty"`
	Folder      *string `json:"folder,omitempty"`
	Title       string  `json:"title"`
}

// SelfStorageLocationInfo defines model for SelfStorageLocationInfo.
type SelfStorageLocationInfo struct {
	BucketName  string `json:"bucketName"`
	BucketPath  string `json:"bucketPath"`
	Description string `json:"description"`
	Folder      string `json:"folder"`
	Title       string `json:"title"`
	Uri         string `json:"uri"`
}

// SelfStorageLocationPolicy defines model for SelfStorageLocationPolicy.
type SelfStorageLocationPolicy struct {
	Message string                 `json:"message"`
	Policy  map[string]interface{} `json:"policy"`
}

// SelfStorageLocationPrefix defines model for SelfStorageLocationPrefix.
type SelfStorageLocationPrefix struct {
	Message string `json:"message"`
	Prefix  string `json:"prefix"`
}

// SelfStorageLocationServiceAccounts defines model for SelfStorageLocationServiceAccounts.
type SelfStorageLocationServiceAccounts struct {
	ClusterMaster string `json:"clusterMaster"`
	Indexer       string `json:"indexer"`
}

// SelfStorageLocationServiceAccountsResponse defines model for SelfStorageLocationServiceAccountsResponse.
type SelfStorageLocationServiceAccountsResponse struct {
	Message         string                              `json:"message"`
	ServiceAccounts *SelfStorageLocationServiceAccounts `json:"serviceAccounts,omitempty"`
}

// the splunkbase app name and version to install. If no version specified, the latest version will be installed.
type SplunkbaseBody struct {
	SplunkbaseID string  `json:"splunkbaseID"`
	Version      *string `json:"version,omitempty"`
}

// StackStatus defines model for StackStatus.
type StackStatus struct {
	Infrastructure struct {

		// the type of the stack (Victoria/Classic)
		StackType *string `json:"stackType,omitempty"`

		// the version of the stack
		StackVersion *string `json:"stackVersion,omitempty"`

		// the status of the infrastructure 1) Ready - The stack is ready, and infrastructure is up to date. 2) Pending - The stack has some pending changes that haven't been applied to the stack yet. The changes could be internal system changes for stacks or user requested changes like modification to allow lists. 3) Failed - There were some errors while applying changes to the stacks were being applied. The changes could be internal system changes for stacks or user requested changes like modification to allow lists. User should reach out to Splunk support for resolution.
		Status *string `json:"status,omitempty"`
	} `json:"infrastructure"`
	Messages struct {

		// The stack has a notification to restart splunk server. User should restart stack via UI for all configurations to be completed. It may take some time for the correct state for restart-required field to be populated in a Search Head Cluster, given sync delays with different Search Heads
		RestartRequired *bool `json:"restartRequired,omitempty"`
	} `json:"messages"`
}

// TokenBody defines model for TokenBody.
type TokenBody struct {
	Audience  string  `json:"audience"`
	ExpiresOn *string `json:"expiresOn,omitempty"`
	Type      *string `json:"type,omitempty"`
	User      string  `json:"user"`
}

// TokenInfo defines model for TokenInfo.
type TokenInfo struct {
	Audience   string     `json:"audience"`
	ExpiresOn  time.Time  `json:"expiresOn"`
	Id         string     `json:"id"`
	LastUsed   *time.Time `json:"lastUsed,omitempty"`
	LastUsedIP *string    `json:"lastUsedIP,omitempty"`
	NotBefore  time.Time  `json:"notBefore"`
	Status     string     `json:"status"`
	Token      *string    `json:"token,omitempty"`
	Type       *string    `json:"type,omitempty"`
	User       string     `json:"user"`
}

// UpdatePrivateConnectivity defines model for UpdatePrivateConnectivity.
type UpdatePrivateConnectivity struct {
	PatchedCustomerAccountIds *[]string `json:"patchedCustomerAccountIds,omitempty"`
}

// Splunk user
type UsersResponse struct {
	Capabilities        []string `json:"capabilities"`
	DefaultApp          string   `json:"defaultApp"`
	DefaultAppSource    string   `json:"defaultAppSource"`
	Email               string   `json:"email"`
	FullName            string   `json:"fullName"`
	LastSuccessfulLogin *string  `json:"lastSuccessfulLogin,omitempty"`
	LockedOut           bool     `json:"lockedOut"`
	Name                string   `json:"name"`
	Roles               []string `json:"roles"`
}

// WarningResponse defines model for WarningResponse.
type WarningResponse struct {
	Warnings *[]string `json:"warnings,omitempty"`
}

// AppName defines model for app-name.
type AppName string

// AppGroup defines model for appGroup.
type AppGroup string

// BucketName defines model for bucketName.
type BucketName string

// BucketPath defines model for bucketPath.
type BucketPath string

// Count defines model for count.
type Count int64

// DeploymentID defines model for deploymentID.
type DeploymentID string

// Feature defines model for feature.
type Feature string

// List of Feature
const (
	Feature_hec        Feature = "hec"
	Feature_idm_api    Feature = "idm-api"
	Feature_idm_ui     Feature = "idm-ui"
	Feature_s2s        Feature = "s2s"
	Feature_search_api Feature = "search-api"
	Feature_search_ui  Feature = "search-ui"
)

// FeatureName defines model for featureName.
type FeatureName string

// FederatedSearchManage defines model for federatedSearchManage.
type FederatedSearchManage string

// FromTime defines model for fromTime.
type FromTime string

// GrantableOnly defines model for grantableOnly.
type GrantableOnly bool

// Hec defines model for hec.
type Hec string

// Index defines model for index.
type Index string

// Key defines model for key.
type Key string

// NextLink defines model for nextLink.
type NextLink string

// Offset defines model for offset.
type Offset int64

// RoleName defines model for roleName.
type RoleName string

// ScheduleID defines model for scheduleID.
type ScheduleID string

// Stack defines model for stack.
type Stack string

// Stanza defines model for stanza.
type Stanza string

// ToTime defines model for toTime.
type ToTime string

// TokenID defines model for tokenID.
type TokenID string

// TokenStatus defines model for tokenStatus.
type TokenStatus string

// UserName defines model for userName.
type UserName string

// Username defines model for username.
type Username string

// DefaultError defines model for defaultError.
type DefaultError Error

// AddOutboundportsJSONBody defines parameters for AddOutboundports.
type AddOutboundportsJSONBody struct {
	OutboundPorts *[]struct {
		Port    *int32    `json:"port,omitempty"`
		Subnets *[]string `json:"subnets,omitempty"`
	} `json:"outboundPorts,omitempty"`
	Reason *string `json:"reason,omitempty"`
}

// DeleteOutboundportJSONBody defines parameters for DeleteOutboundport.
type DeleteOutboundportJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// DeleteSubnetsJSONBody defines parameters for DeleteSubnets.
type DeleteSubnetsJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// AddSubnetsJSONBody defines parameters for AddSubnets.
type AddSubnetsJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`

	// filter apps based on splunkbase and non-splunkbase apps
	Splunkbase *bool `json:"splunkbase,omitempty"`
}

// InstallAppParams defines parameters for InstallApp.
type InstallAppParams struct {

	// is the app available in splunkbase
	Splunkbase *bool `json:"splunkbase,omitempty"`

	// ACS-Legal-Ack is required for installing private apps
	ACSLegalAck string `json:"ACS-Legal-Ack"`

	// Splunkbase sessionID
	XSplunkbaseAuthorization *string `json:"X-Splunkbase-Authorization,omitempty"`

	// The app inspect token
	XSplunkAuthorization *string `json:"X-Splunk-Authorization,omitempty"`

	// ACS-Licensing-Ack is required for installing splunkbase apps
	ACSLicensingAck *string `json:"ACS-Licensing-Ack,omitempty"`
}

// ListAppsVictoriaParams defines parameters for ListAppsVictoria.
type ListAppsVictoriaParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`

	// filter apps based on splunkbase and non-splunkbase apps
	Splunkbase *bool `json:"splunkbase,omitempty"`
}

// InstallAppVictoriaParams defines parameters for InstallAppVictoria.
type InstallAppVictoriaParams struct {

	// is the app available in splunkbase
	Splunkbase *bool `json:"splunkbase,omitempty"`

	// Splunkbase sessionID
	XSplunkbaseAuthorization *string `json:"X-Splunkbase-Authorization,omitempty"`

	// The app inspect token
	XSplunkAuthorization *string `json:"X-Splunk-Authorization,omitempty"`

	// ACS-Legal-Ack is required for installing private apps
	ACSLegalAck *string `json:"ACS-Legal-Ack,omitempty"`

	// ACS-Licensing-Ack is required for installing splunkbase apps
	ACSLicensingAck *string `json:"ACS-Licensing-Ack,omitempty"`
}

// PatchAppVictoriaParams defines parameters for PatchAppVictoria.
type PatchAppVictoriaParams struct {

	// The splunkbase sessionID
	XSplunkbaseAuthorization string `json:"X-Splunkbase-Authorization"`

	// ACS-Licensing-Ack is required for updating splunkbase apps
	ACSLicensingAck string `json:"ACS-Licensing-Ack"`
}

// PatchAppClassicParams defines parameters for PatchAppClassic.
type PatchAppClassicParams struct {

	// The splunkbase sessionID
	XSplunkbaseAuthorization string `json:"X-Splunkbase-Authorization"`

	// ACS-Licensing-Ack is required for updating splunkbase apps
	ACSLicensingAck string `json:"ACS-Licensing-Ack"`
}

// ListCapabilitiesParams defines parameters for ListCapabilities.
type ListCapabilitiesParams struct {

	// only show grantable capabilities
	GrantableOnly *GrantableOnly `json:"grantableOnly,omitempty"`
}

// ListSelfStorageLocationsParams defines parameters for ListSelfStorageLocations.
type ListSelfStorageLocationsParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// CreateSelfStorageLocationJSONBody defines parameters for CreateSelfStorageLocation.
type CreateSelfStorageLocationJSONBody SelfStorageLocationBody

// SetAppFeatureEnablementJSONBody defines parameters for SetAppFeatureEnablement.
type SetAppFeatureEnablementJSONBody AppFeatureEnablement

// ListIndexesParams defines parameters for ListIndexes.
type ListIndexesParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// CreateIndexJSONBody defines parameters for CreateIndex.
type CreateIndexJSONBody IndexInfo

// DeleteIndexJSONBody defines parameters for DeleteIndex.
type DeleteIndexJSONBody map[string]interface{}

// PatchIndexInfoJSONBody defines parameters for PatchIndexInfo.
type PatchIndexInfoJSONBody PatchIndexInfo

// ListHECsParams defines parameters for ListHECs.
type ListHECsParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// CreateHECJSONBody defines parameters for CreateHEC.
type CreateHECJSONBody HecSpec

// DeleteHecJSONBody defines parameters for DeleteHec.
type DeleteHecJSONBody map[string]interface{}

// PatchHECJSONBody defines parameters for PatchHEC.
type PatchHECJSONBody HecSpec

// UpdateHECJSONBody defines parameters for UpdateHEC.
type UpdateHECJSONBody HecSpec

// AddLimitConfigJSONBody defines parameters for AddLimitConfig.
type AddLimitConfigJSONBody LimitConfigurationInfo

// ResetLimitConfigJSONBody defines parameters for ResetLimitConfig.
type ResetLimitConfigJSONBody LimitResetSettingsList

// ListMaintenanceWindowsSchedulesParams defines parameters for ListMaintenanceWindowsSchedules.
type ListMaintenanceWindowsSchedulesParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// nextLink to the next segment of the result set. A nextLink with the value null indicates there are no more pages. UTC is the default timezone.
	NextLink *NextLink `json:"nextLink,omitempty"`

	// the earliest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	FromTime *FromTime `json:"fromTime,omitempty"`

	// the latest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	ToTime *ToTime `json:"toTime,omitempty"`
}

// AuditMaintenanceWindowsScheduleParams defines parameters for AuditMaintenanceWindowsSchedule.
type AuditMaintenanceWindowsScheduleParams struct {

	// the earliest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	FromTime *FromTime `json:"fromTime,omitempty"`

	// the latest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	ToTime *ToTime `json:"toTime,omitempty"`
}

// ListPermissionsAppsParams defines parameters for ListPermissionsApps.
type ListPermissionsAppsParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// PatchPermissionsAppsJSONBody defines parameters for PatchPermissionsApps.
type PatchPermissionsAppsJSONBody PatchAppPermsRequest

// UpdatePrivateConnectivityJSONBody defines parameters for UpdatePrivateConnectivity.
type UpdatePrivateConnectivityJSONBody EnablePrivateConnectivity

// EnablePrivateConnectivityJSONBody defines parameters for EnablePrivateConnectivity.
type EnablePrivateConnectivityJSONBody EnablePrivateConnectivity

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody PostRolesRequest

// CreateRoleParams defines parameters for CreateRole.
type CreateRoleParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// PatchRoleInfoJSONBody defines parameters for PatchRoleInfo.
type PatchRoleInfoJSONBody RolesRequest

// PatchRoleInfoParams defines parameters for PatchRoleInfo.
type PatchRoleInfoParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`

	// status of tokens wanted
	Status *TokenStatus `json:"status,omitempty"`

	// user of tokens wanted
	Username *Username `json:"username,omitempty"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody TokenBody

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// the count of items to return
	Count *Count `json:"count,omitempty"`

	// the offset to start return items from
	Offset *Offset `json:"offset,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody CreateUserRequest

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// PatchUserJSONBody defines parameters for PatchUser.
type PatchUserJSONBody PatchUserRequest

// PatchUserParams defines parameters for PatchUser.
type PatchUserParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// AddOutboundportsJSONRequestBody defines body for AddOutboundports for application/json ContentType.
type AddOutboundportsJSONRequestBody AddOutboundportsJSONBody

// DeleteOutboundportJSONRequestBody defines body for DeleteOutboundport for application/json ContentType.
type DeleteOutboundportJSONRequestBody DeleteOutboundportJSONBody

// DeleteSubnetsJSONRequestBody defines body for DeleteSubnets for application/json ContentType.
type DeleteSubnetsJSONRequestBody DeleteSubnetsJSONBody

// AddSubnetsJSONRequestBody defines body for AddSubnets for application/json ContentType.
type AddSubnetsJSONRequestBody AddSubnetsJSONBody

// CreateSelfStorageLocationJSONRequestBody defines body for CreateSelfStorageLocation for application/json ContentType.
type CreateSelfStorageLocationJSONRequestBody CreateSelfStorageLocationJSONBody

// SetAppFeatureEnablementJSONRequestBody defines body for SetAppFeatureEnablement for application/json ContentType.
type SetAppFeatureEnablementJSONRequestBody SetAppFeatureEnablementJSONBody

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody CreateIndexJSONBody

// DeleteIndexJSONRequestBody defines body for DeleteIndex for application/json ContentType.
type DeleteIndexJSONRequestBody DeleteIndexJSONBody

// PatchIndexInfoJSONRequestBody defines body for PatchIndexInfo for application/json ContentType.
type PatchIndexInfoJSONRequestBody PatchIndexInfoJSONBody

// CreateHECJSONRequestBody defines body for CreateHEC for application/json ContentType.
type CreateHECJSONRequestBody CreateHECJSONBody

// DeleteHecJSONRequestBody defines body for DeleteHec for application/json ContentType.
type DeleteHecJSONRequestBody DeleteHecJSONBody

// PatchHECJSONRequestBody defines body for PatchHEC for application/json ContentType.
type PatchHECJSONRequestBody PatchHECJSONBody

// UpdateHECJSONRequestBody defines body for UpdateHEC for application/json ContentType.
type UpdateHECJSONRequestBody UpdateHECJSONBody

// AddLimitConfigJSONRequestBody defines body for AddLimitConfig for application/json ContentType.
type AddLimitConfigJSONRequestBody AddLimitConfigJSONBody

// ResetLimitConfigJSONRequestBody defines body for ResetLimitConfig for application/json ContentType.
type ResetLimitConfigJSONRequestBody ResetLimitConfigJSONBody

// PatchPermissionsAppsJSONRequestBody defines body for PatchPermissionsApps for application/json ContentType.
type PatchPermissionsAppsJSONRequestBody PatchPermissionsAppsJSONBody

// UpdatePrivateConnectivityJSONRequestBody defines body for UpdatePrivateConnectivity for application/json ContentType.
type UpdatePrivateConnectivityJSONRequestBody UpdatePrivateConnectivityJSONBody

// EnablePrivateConnectivityJSONRequestBody defines body for EnablePrivateConnectivity for application/json ContentType.
type EnablePrivateConnectivityJSONRequestBody EnablePrivateConnectivityJSONBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody CreateRoleJSONBody

// PatchRoleInfoJSONRequestBody defines body for PatchRoleInfo for application/json ContentType.
type PatchRoleInfoJSONRequestBody PatchRoleInfoJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody CreateTokenJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// PatchUserJSONRequestBody defines body for PatchUser for application/json ContentType.
type PatchUserJSONRequestBody PatchUserJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOutboundports request
	GetOutboundports(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOutboundports request  with any body
	AddOutboundportsWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOutboundports(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutboundport request  with any body
	DeleteOutboundportWithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteOutboundport(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeOutboundports request
	DescribeOutboundports(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnets request  with any body
	DeleteSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSubnets(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAllowlist request
	DescribeAllowlist(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSubnets request  with any body
	AddSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSubnets(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallApp request  with any body
	InstallAppWithBody(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppsVictoria request
	ListAppsVictoria(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAppVictoria request  with any body
	InstallAppVictoriaWithBody(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallAppVictoria request
	UninstallAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAppVictoria request
	DescribeAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppVictoria request  with any body
	PatchAppVictoriaWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallApp request
	UninstallApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeApp request
	DescribeApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppClassic request  with any body
	PatchAppClassicWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCapabilities request
	ListCapabilities(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSelfStorageLocations request
	ListSelfStorageLocations(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSelfStorageLocation request  with any body
	CreateSelfStorageLocationWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSelfStorageLocation(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationPolicy request
	GetSelfStorageLocationPolicy(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeSelfStorageLocation request
	DescribeSelfStorageLocation(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationPrefix request
	GetSelfStorageLocationPrefix(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationServiceAccounts request
	GetSelfStorageLocationServiceAccounts(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryDeployment request
	RetryDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployment request
	ListDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeDeployment request
	DescribeDeployment(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAppFeatureEnablement request
	DescribeAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppFeatureEnablement request  with any body
	SetAppFeatureEnablementWithBody(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexes request
	ListIndexes(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndex request  with any body
	CreateIndexWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request  with any body
	DeleteIndexWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIndex(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexInfo request
	GetIndexInfo(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchIndexInfo request  with any body
	PatchIndexInfoWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchIndexInfo(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHECs request
	ListHECs(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHEC request  with any body
	CreateHECWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHEC(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHec request  with any body
	DeleteHecWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteHec(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeHec request
	DescribeHec(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchHEC request  with any body
	PatchHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchHEC(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHEC request  with any body
	UpdateHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateHEC(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLimitsConfig request
	GetAllLimitsConfig(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLimitsConfigDefaults request
	GetAllLimitsConfigDefaults(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimitConfig request
	GetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLimitConfig request  with any body
	AddLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimitsConfigDefaults request
	GetLimitsConfigDefaults(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetLimitConfig request  with any body
	ResetLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyLimitConfig request
	GetKeyLimitConfig(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMaintenanceWindowsSchedules request
	ListMaintenanceWindowsSchedules(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeMaintenanceWindowsSchedule request
	DescribeMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditMaintenanceWindowsSchedule request
	AuditMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsApps request
	ListPermissionsApps(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribePermissionsApps request
	DescribePermissionsApps(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPermissionsApps request  with any body
	PatchPermissionsAppsWithBody(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPermissionsApps(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidatePrivateConnectivity request
	ValidatePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribePrivateConnectivity request
	DescribePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePrivateConnectivity request  with any body
	UpdatePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePrivateConnectivity(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnablePrivateConnectivity request  with any body
	EnablePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnablePrivateConnectivity(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartStack request
	RestartStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartStatus request
	RestartStatus(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRole request  with any body
	CreateRoleWithBody(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeRole request
	DescribeRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRoleInfo request  with any body
	PatchRoleInfoWithBody(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRoleInfo(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeStack request
	DescribeStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request  with any body
	CreateTokenWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenInfo request
	GetTokenInfo(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeUser request
	DescribeUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUser request  with any body
	PatchUserWithBody(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUser(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOutboundports(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutboundportsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOutboundportsWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOutboundportsRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOutboundports(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOutboundportsRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundportWithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundportRequestWithBody(c.Server, stack, port, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundport(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundportRequest(c.Server, stack, port, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeOutboundports(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeOutboundportsRequest(c.Server, stack, port)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetsRequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnets(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetsRequest(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAllowlist(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAllowlistRequest(c.Server, stack, feature)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubnetsRequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubnets(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubnetsRequest(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, stack, feature, subnet)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAppWithBody(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAppRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppsVictoria(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsVictoriaRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAppVictoriaWithBody(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAppVictoriaRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppVictoriaRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppVictoriaRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppVictoriaWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppVictoriaRequestWithBody(c.Server, stack, app, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppClassicWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppClassicRequestWithBody(c.Server, stack, app, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCapabilities(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCapabilitiesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSelfStorageLocations(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSelfStorageLocationsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfStorageLocationWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfStorageLocationRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfStorageLocation(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfStorageLocationRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationPolicy(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationPolicyRequest(c.Server, stack, bucketName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeSelfStorageLocation(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeSelfStorageLocationRequest(c.Server, stack, bucketPath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationPrefix(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationPrefixRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationServiceAccounts(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationServiceAccountsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryDeploymentRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeDeployment(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeDeploymentRequest(c.Server, stack, deploymentID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppFeatureEnablementRequest(c.Server, stack, appGroup, featureName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppFeatureEnablementWithBody(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppFeatureEnablementRequestWithBody(c.Server, stack, appGroup, featureName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppFeatureEnablementRequest(c.Server, stack, appGroup, featureName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexes(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndexWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequestWithBody(c.Server, stack, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, stack, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexInfo(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexInfoRequest(c.Server, stack, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchIndexInfoWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchIndexInfoRequestWithBody(c.Server, stack, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchIndexInfo(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchIndexInfoRequest(c.Server, stack, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHECs(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHECsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHECWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHECRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHEC(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHECRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHecWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHecRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHec(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHecRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeHec(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeHecRequest(c.Server, stack, hec)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchHECRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchHEC(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchHECRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHECRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHEC(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHECRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLimitsConfig(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLimitsConfigRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLimitsConfigDefaults(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLimitsConfigDefaultsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitConfigRequest(c.Server, stack, stanza)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLimitConfigRequestWithBody(c.Server, stack, stanza, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLimitConfigRequest(c.Server, stack, stanza, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimitsConfigDefaults(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitsConfigDefaultsRequest(c.Server, stack, stanza)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetLimitConfigRequestWithBody(c.Server, stack, stanza, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetLimitConfigRequest(c.Server, stack, stanza, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyLimitConfig(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyLimitConfigRequest(c.Server, stack, stanza, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMaintenanceWindowsSchedules(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMaintenanceWindowsSchedulesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeMaintenanceWindowsScheduleRequest(c.Server, stack, scheduleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditMaintenanceWindowsScheduleRequest(c.Server, stack, scheduleID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsApps(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsAppsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribePermissionsApps(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribePermissionsAppsRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPermissionsAppsWithBody(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPermissionsAppsRequestWithBody(c.Server, stack, app, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPermissionsApps(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPermissionsAppsRequest(c.Server, stack, app, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePrivateConnectivityRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribePrivateConnectivityRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateConnectivityRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateConnectivity(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateConnectivityRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePrivateConnectivityRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePrivateConnectivity(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePrivateConnectivityRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartStackRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartStatus(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartStatusRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, stack, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, stack, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeRoleRequest(c.Server, stack, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoleInfoWithBody(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleInfoRequestWithBody(c.Server, stack, roleName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoleInfo(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleInfoRequest(c.Server, stack, roleName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeStackRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, stack, tokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenInfo(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenInfoRequest(c.Server, stack, tokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, stack, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, stack, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeUserRequest(c.Server, stack, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, stack, userName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUser(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequest(c.Server, stack, userName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOutboundportsRequest generates requests for GetOutboundports
func NewGetOutboundportsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOutboundportsRequest calls the generic AddOutboundports builder with application/json body
func NewAddOutboundportsRequest(server string, stack Stack, body AddOutboundportsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOutboundportsRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewAddOutboundportsRequestWithBody generates requests for AddOutboundports with any type of body
func NewAddOutboundportsRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutboundportRequest calls the generic DeleteOutboundport builder with application/json body
func NewDeleteOutboundportRequest(server string, stack Stack, port int32, body DeleteOutboundportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteOutboundportRequestWithBody(server, stack, port, "application/json", bodyReader)
}

// NewDeleteOutboundportRequestWithBody generates requests for DeleteOutboundport with any type of body
func NewDeleteOutboundportRequestWithBody(server string, stack Stack, port int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeOutboundportsRequest generates requests for DescribeOutboundports
func NewDescribeOutboundportsRequest(server string, stack Stack, port int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSubnetsRequest calls the generic DeleteSubnets builder with application/json body
func NewDeleteSubnetsRequest(server string, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSubnetsRequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewDeleteSubnetsRequestWithBody generates requests for DeleteSubnets with any type of body
func NewDeleteSubnetsRequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeAllowlistRequest generates requests for DescribeAllowlist
func NewDescribeAllowlistRequest(server string, stack Stack, feature Feature) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSubnetsRequest calls the generic AddSubnets builder with application/json body
func NewAddSubnetsRequest(server string, stack Stack, feature Feature, body AddSubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSubnetsRequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewAddSubnetsRequestWithBody generates requests for AddSubnets with any type of body
func NewAddSubnetsRequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, stack Stack, feature Feature, subnet string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subnet", runtime.ParamLocationPath, subnet)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, stack Stack, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallAppRequestWithBody generates requests for InstallApp with any type of body
func NewInstallAppRequestWithBody(server string, stack Stack, params *InstallAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "ACS-Legal-Ack", runtime.ParamLocationHeader, params.ACSLegalAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Legal-Ack", headerParam0)

	if params.XSplunkbaseAuthorization != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, *params.XSplunkbaseAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunkbase-Authorization", headerParam1)
	}

	if params.XSplunkAuthorization != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Splunk-Authorization", runtime.ParamLocationHeader, *params.XSplunkAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunk-Authorization", headerParam2)
	}

	if params.ACSLicensingAck != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, *params.ACSLicensingAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Licensing-Ack", headerParam3)
	}

	return req, nil
}

// NewListAppsVictoriaRequest generates requests for ListAppsVictoria
func NewListAppsVictoriaRequest(server string, stack Stack, params *ListAppsVictoriaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallAppVictoriaRequestWithBody generates requests for InstallAppVictoria with any type of body
func NewInstallAppVictoriaRequestWithBody(server string, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XSplunkbaseAuthorization != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, *params.XSplunkbaseAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunkbase-Authorization", headerParam0)
	}

	if params.XSplunkAuthorization != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Splunk-Authorization", runtime.ParamLocationHeader, *params.XSplunkAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunk-Authorization", headerParam1)
	}

	if params.ACSLegalAck != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "ACS-Legal-Ack", runtime.ParamLocationHeader, *params.ACSLegalAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Legal-Ack", headerParam2)
	}

	if params.ACSLicensingAck != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, *params.ACSLicensingAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Licensing-Ack", headerParam3)
	}

	return req, nil
}

// NewUninstallAppVictoriaRequest generates requests for UninstallAppVictoria
func NewUninstallAppVictoriaRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppVictoriaRequest generates requests for DescribeAppVictoria
func NewDescribeAppVictoriaRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppVictoriaRequestWithBody generates requests for PatchAppVictoria with any type of body
func NewPatchAppVictoriaRequestWithBody(server string, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, params.XSplunkbaseAuthorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-Splunkbase-Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, params.ACSLicensingAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Licensing-Ack", headerParam1)

	return req, nil
}

// NewUninstallAppRequest generates requests for UninstallApp
func NewUninstallAppRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppRequest generates requests for DescribeApp
func NewDescribeAppRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppClassicRequestWithBody generates requests for PatchAppClassic with any type of body
func NewPatchAppClassicRequestWithBody(server string, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, params.XSplunkbaseAuthorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-Splunkbase-Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, params.ACSLicensingAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Licensing-Ack", headerParam1)

	return req, nil
}

// NewListCapabilitiesRequest generates requests for ListCapabilities
func NewListCapabilitiesRequest(server string, stack Stack, params *ListCapabilitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/capabilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.GrantableOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grantableOnly", runtime.ParamLocationQuery, *params.GrantableOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSelfStorageLocationsRequest generates requests for ListSelfStorageLocations
func NewListSelfStorageLocationsRequest(server string, stack Stack, params *ListSelfStorageLocationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSelfStorageLocationRequest calls the generic CreateSelfStorageLocation builder with application/json body
func NewCreateSelfStorageLocationRequest(server string, stack Stack, body CreateSelfStorageLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSelfStorageLocationRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateSelfStorageLocationRequestWithBody generates requests for CreateSelfStorageLocation with any type of body
func NewCreateSelfStorageLocationRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSelfStorageLocationPolicyRequest generates requests for GetSelfStorageLocationPolicy
func NewGetSelfStorageLocationPolicyRequest(server string, stack Stack, bucketName BucketName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucketName", runtime.ParamLocationPath, bucketName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets/%s/policy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeSelfStorageLocationRequest generates requests for DescribeSelfStorageLocation
func NewDescribeSelfStorageLocationRequest(server string, stack Stack, bucketPath BucketPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucketPath", runtime.ParamLocationPath, bucketPath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelfStorageLocationPrefixRequest generates requests for GetSelfStorageLocationPrefix
func NewGetSelfStorageLocationPrefixRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/configs/prefix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelfStorageLocationServiceAccountsRequest generates requests for GetSelfStorageLocationServiceAccounts
func NewGetSelfStorageLocationServiceAccountsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/configs/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryDeploymentRequest generates requests for RetryDeployment
func NewRetryDeploymentRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/retry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentRequest generates requests for ListDeployment
func NewListDeploymentRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeDeploymentRequest generates requests for DescribeDeployment
func NewDescribeDeploymentRequest(server string, stack Stack, deploymentID DeploymentID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentID", runtime.ParamLocationPath, deploymentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppFeatureEnablementRequest generates requests for DescribeAppFeatureEnablement
func NewDescribeAppFeatureEnablementRequest(server string, stack Stack, appGroup AppGroup, featureName FeatureName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appGroup", runtime.ParamLocationPath, appGroup)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/enablement/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAppFeatureEnablementRequest calls the generic SetAppFeatureEnablement builder with application/json body
func NewSetAppFeatureEnablementRequest(server string, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppFeatureEnablementRequestWithBody(server, stack, appGroup, featureName, "application/json", bodyReader)
}

// NewSetAppFeatureEnablementRequestWithBody generates requests for SetAppFeatureEnablement with any type of body
func NewSetAppFeatureEnablementRequestWithBody(server string, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appGroup", runtime.ParamLocationPath, appGroup)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/enablement/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIndexesRequest generates requests for ListIndexes
func NewListIndexesRequest(server string, stack Stack, params *ListIndexesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, stack Stack, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIndexRequest calls the generic DeleteIndex builder with application/json body
func NewDeleteIndexRequest(server string, stack Stack, index Index, body DeleteIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIndexRequestWithBody(server, stack, index, "application/json", bodyReader)
}

// NewDeleteIndexRequestWithBody generates requests for DeleteIndex with any type of body
func NewDeleteIndexRequestWithBody(server string, stack Stack, index Index, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIndexInfoRequest generates requests for GetIndexInfo
func NewGetIndexInfoRequest(server string, stack Stack, index Index) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchIndexInfoRequest calls the generic PatchIndexInfo builder with application/json body
func NewPatchIndexInfoRequest(server string, stack Stack, index Index, body PatchIndexInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchIndexInfoRequestWithBody(server, stack, index, "application/json", bodyReader)
}

// NewPatchIndexInfoRequestWithBody generates requests for PatchIndexInfo with any type of body
func NewPatchIndexInfoRequestWithBody(server string, stack Stack, index Index, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListHECsRequest generates requests for ListHECs
func NewListHECsRequest(server string, stack Stack, params *ListHECsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHECRequest calls the generic CreateHEC builder with application/json body
func NewCreateHECRequest(server string, stack Stack, body CreateHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHECRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateHECRequestWithBody generates requests for CreateHEC with any type of body
func NewCreateHECRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHecRequest calls the generic DeleteHec builder with application/json body
func NewDeleteHecRequest(server string, stack Stack, hec Hec, body DeleteHecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteHecRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewDeleteHecRequestWithBody generates requests for DeleteHec with any type of body
func NewDeleteHecRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeHecRequest generates requests for DescribeHec
func NewDescribeHecRequest(server string, stack Stack, hec Hec) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchHECRequest calls the generic PatchHEC builder with application/json body
func NewPatchHECRequest(server string, stack Stack, hec Hec, body PatchHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchHECRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewPatchHECRequestWithBody generates requests for PatchHEC with any type of body
func NewPatchHECRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateHECRequest calls the generic UpdateHEC builder with application/json body
func NewUpdateHECRequest(server string, stack Stack, hec Hec, body UpdateHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateHECRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewUpdateHECRequestWithBody generates requests for UpdateHEC with any type of body
func NewUpdateHECRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLimitsConfigRequest generates requests for GetAllLimitsConfig
func NewGetAllLimitsConfigRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllLimitsConfigDefaultsRequest generates requests for GetAllLimitsConfigDefaults
func NewGetAllLimitsConfigDefaultsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/defaults", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLimitConfigRequest generates requests for GetLimitConfig
func NewGetLimitConfigRequest(server string, stack Stack, stanza Stanza) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLimitConfigRequest calls the generic AddLimitConfig builder with application/json body
func NewAddLimitConfigRequest(server string, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLimitConfigRequestWithBody(server, stack, stanza, "application/json", bodyReader)
}

// NewAddLimitConfigRequestWithBody generates requests for AddLimitConfig with any type of body
func NewAddLimitConfigRequestWithBody(server string, stack Stack, stanza Stanza, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLimitsConfigDefaultsRequest generates requests for GetLimitsConfigDefaults
func NewGetLimitsConfigDefaultsRequest(server string, stack Stack, stanza Stanza) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/defaults", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetLimitConfigRequest calls the generic ResetLimitConfig builder with application/json body
func NewResetLimitConfigRequest(server string, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetLimitConfigRequestWithBody(server, stack, stanza, "application/json", bodyReader)
}

// NewResetLimitConfigRequestWithBody generates requests for ResetLimitConfig with any type of body
func NewResetLimitConfigRequestWithBody(server string, stack Stack, stanza Stanza, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeyLimitConfigRequest generates requests for GetKeyLimitConfig
func NewGetKeyLimitConfigRequest(server string, stack Stack, stanza Stanza, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMaintenanceWindowsSchedulesRequest generates requests for ListMaintenanceWindowsSchedules
func NewListMaintenanceWindowsSchedulesRequest(server string, stack Stack, params *ListMaintenanceWindowsSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextLink != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextLink", runtime.ParamLocationQuery, *params.NextLink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FromTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTime", runtime.ParamLocationQuery, *params.FromTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTime", runtime.ParamLocationQuery, *params.ToTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeMaintenanceWindowsScheduleRequest generates requests for DescribeMaintenanceWindowsSchedule
func NewDescribeMaintenanceWindowsScheduleRequest(server string, stack Stack, scheduleID ScheduleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduleID", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuditMaintenanceWindowsScheduleRequest generates requests for AuditMaintenanceWindowsSchedule
func NewAuditMaintenanceWindowsScheduleRequest(server string, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduleID", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules/%s/audits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.FromTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTime", runtime.ParamLocationQuery, *params.FromTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTime", runtime.ParamLocationQuery, *params.ToTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPermissionsAppsRequest generates requests for ListPermissionsApps
func NewListPermissionsAppsRequest(server string, stack Stack, params *ListPermissionsAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribePermissionsAppsRequest generates requests for DescribePermissionsApps
func NewDescribePermissionsAppsRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPermissionsAppsRequest calls the generic PatchPermissionsApps builder with application/json body
func NewPatchPermissionsAppsRequest(server string, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPermissionsAppsRequestWithBody(server, stack, app, "application/json", bodyReader)
}

// NewPatchPermissionsAppsRequestWithBody generates requests for PatchPermissionsApps with any type of body
func NewPatchPermissionsAppsRequestWithBody(server string, stack Stack, app AppName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidatePrivateConnectivityRequest generates requests for ValidatePrivateConnectivity
func NewValidatePrivateConnectivityRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/eligibility", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribePrivateConnectivityRequest generates requests for DescribePrivateConnectivity
func NewDescribePrivateConnectivityRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePrivateConnectivityRequest calls the generic UpdatePrivateConnectivity builder with application/json body
func NewUpdatePrivateConnectivityRequest(server string, stack Stack, body UpdatePrivateConnectivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePrivateConnectivityRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewUpdatePrivateConnectivityRequestWithBody generates requests for UpdatePrivateConnectivity with any type of body
func NewUpdatePrivateConnectivityRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnablePrivateConnectivityRequest calls the generic EnablePrivateConnectivity builder with application/json body
func NewEnablePrivateConnectivityRequest(server string, stack Stack, body EnablePrivateConnectivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnablePrivateConnectivityRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewEnablePrivateConnectivityRequestWithBody generates requests for EnablePrivateConnectivity with any type of body
func NewEnablePrivateConnectivityRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartStackRequest generates requests for RestartStack
func NewRestartStackRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/restart-now", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartStatusRequest generates requests for RestartStatus
func NewRestartStatusRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/restart/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, stack Stack, params *ListRolesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, stack, params, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, stack Stack, params *CreateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, stack Stack, roleName RoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeRoleRequest generates requests for DescribeRole
func NewDescribeRoleRequest(server string, stack Stack, roleName RoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRoleInfoRequest calls the generic PatchRoleInfo builder with application/json body
func NewPatchRoleInfoRequest(server string, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRoleInfoRequestWithBody(server, stack, roleName, params, "application/json", bodyReader)
}

// NewPatchRoleInfoRequestWithBody generates requests for PatchRoleInfo with any type of body
func NewPatchRoleInfoRequestWithBody(server string, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDescribeStackRequest generates requests for DescribeStack
func NewDescribeStackRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, stack Stack, params *ListTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Username != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, stack Stack, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, stack Stack, tokenID TokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenInfoRequest generates requests for GetTokenInfo
func NewGetTokenInfoRequest(server string, stack Stack, tokenID TokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, stack Stack, params *ListUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, stack, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, stack Stack, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, stack Stack, userName UserName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeUserRequest generates requests for DescribeUser
func NewDescribeUserRequest(server string, stack Stack, userName UserName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserRequest calls the generic PatchUser builder with application/json body
func NewPatchUserRequest(server string, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, stack, userName, params, "application/json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOutboundports request
	GetOutboundportsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetOutboundportsResponse, error)

	// AddOutboundports request  with any body
	AddOutboundportsWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error)

	AddOutboundportsWithResponse(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error)

	// DeleteOutboundport request  with any body
	DeleteOutboundportWithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error)

	DeleteOutboundportWithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error)

	// DescribeOutboundports request
	DescribeOutboundportsWithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsResponse, error)

	// DeleteSubnets request  with any body
	DeleteSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error)

	DeleteSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error)

	// DescribeAllowlist request
	DescribeAllowlistWithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistResponse, error)

	// AddSubnets request  with any body
	AddSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error)

	AddSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error)

	// DeleteSubnet request
	DeleteSubnetWithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ListApps request
	ListAppsWithResponse(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// InstallApp request  with any body
	InstallAppWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppResponse, error)

	// ListAppsVictoria request
	ListAppsVictoriaWithResponse(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*ListAppsVictoriaResponse, error)

	// InstallAppVictoria request  with any body
	InstallAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppVictoriaResponse, error)

	// UninstallAppVictoria request
	UninstallAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppVictoriaResponse, error)

	// DescribeAppVictoria request
	DescribeAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppVictoriaResponse, error)

	// PatchAppVictoria request  with any body
	PatchAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppVictoriaResponse, error)

	// UninstallApp request
	UninstallAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error)

	// DescribeApp request
	DescribeAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppResponse, error)

	// PatchAppClassic request  with any body
	PatchAppClassicWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppClassicResponse, error)

	// ListCapabilities request
	ListCapabilitiesWithResponse(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*ListCapabilitiesResponse, error)

	// ListSelfStorageLocations request
	ListSelfStorageLocationsWithResponse(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*ListSelfStorageLocationsResponse, error)

	// CreateSelfStorageLocation request  with any body
	CreateSelfStorageLocationWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error)

	CreateSelfStorageLocationWithResponse(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error)

	// GetSelfStorageLocationPolicy request
	GetSelfStorageLocationPolicyWithResponse(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPolicyResponse, error)

	// DescribeSelfStorageLocation request
	DescribeSelfStorageLocationWithResponse(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*DescribeSelfStorageLocationResponse, error)

	// GetSelfStorageLocationPrefix request
	GetSelfStorageLocationPrefixWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPrefixResponse, error)

	// GetSelfStorageLocationServiceAccounts request
	GetSelfStorageLocationServiceAccountsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationServiceAccountsResponse, error)

	// RetryDeployment request
	RetryDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RetryDeploymentResponse, error)

	// ListDeployment request
	ListDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListDeploymentResponse, error)

	// DescribeDeployment request
	DescribeDeploymentWithResponse(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*DescribeDeploymentResponse, error)

	// DescribeAppFeatureEnablement request
	DescribeAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*DescribeAppFeatureEnablementResponse, error)

	// SetAppFeatureEnablement request  with any body
	SetAppFeatureEnablementWithBodyWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error)

	SetAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error)

	// ListIndexes request
	ListIndexesWithResponse(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error)

	// CreateIndex request  with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// DeleteIndex request  with any body
	DeleteIndexWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	DeleteIndexWithResponse(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// GetIndexInfo request
	GetIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*GetIndexInfoResponse, error)

	// PatchIndexInfo request  with any body
	PatchIndexInfoWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error)

	PatchIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error)

	// ListHECs request
	ListHECsWithResponse(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*ListHECsResponse, error)

	// CreateHEC request  with any body
	CreateHECWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHECResponse, error)

	CreateHECWithResponse(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHECResponse, error)

	// DeleteHec request  with any body
	DeleteHecWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error)

	DeleteHecWithResponse(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error)

	// DescribeHec request
	DescribeHecWithResponse(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*DescribeHecResponse, error)

	// PatchHEC request  with any body
	PatchHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchHECResponse, error)

	PatchHECWithResponse(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchHECResponse, error)

	// UpdateHEC request  with any body
	UpdateHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error)

	UpdateHECWithResponse(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error)

	// GetAllLimitsConfig request
	GetAllLimitsConfigWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigResponse, error)

	// GetAllLimitsConfigDefaults request
	GetAllLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigDefaultsResponse, error)

	// GetLimitConfig request
	GetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitConfigResponse, error)

	// AddLimitConfig request  with any body
	AddLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error)

	AddLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error)

	// GetLimitsConfigDefaults request
	GetLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitsConfigDefaultsResponse, error)

	// ResetLimitConfig request  with any body
	ResetLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error)

	ResetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error)

	// GetKeyLimitConfig request
	GetKeyLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*GetKeyLimitConfigResponse, error)

	// ListMaintenanceWindowsSchedules request
	ListMaintenanceWindowsSchedulesWithResponse(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*ListMaintenanceWindowsSchedulesResponse, error)

	// DescribeMaintenanceWindowsSchedule request
	DescribeMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsScheduleResponse, error)

	// AuditMaintenanceWindowsSchedule request
	AuditMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*AuditMaintenanceWindowsScheduleResponse, error)

	// ListPermissionsApps request
	ListPermissionsAppsWithResponse(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*ListPermissionsAppsResponse, error)

	// DescribePermissionsApps request
	DescribePermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribePermissionsAppsResponse, error)

	// PatchPermissionsApps request  with any body
	PatchPermissionsAppsWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error)

	PatchPermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error)

	// ValidatePrivateConnectivity request
	ValidatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ValidatePrivateConnectivityResponse, error)

	// DescribePrivateConnectivity request
	DescribePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribePrivateConnectivityResponse, error)

	// UpdatePrivateConnectivity request  with any body
	UpdatePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error)

	UpdatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error)

	// EnablePrivateConnectivity request  with any body
	EnablePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error)

	EnablePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error)

	// RestartStack request
	RestartStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStackResponse, error)

	// RestartStatus request
	RestartStatusWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStatusResponse, error)

	// ListRoles request
	ListRolesWithResponse(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// CreateRole request  with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteRole request
	DeleteRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// DescribeRole request
	DescribeRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DescribeRoleResponse, error)

	// PatchRoleInfo request  with any body
	PatchRoleInfoWithBodyWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error)

	PatchRoleInfoWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error)

	// DescribeStack request
	DescribeStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeStackResponse, error)

	// ListTokens request
	ListTokensWithResponse(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// CreateToken request  with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteToken request
	DeleteTokenWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetTokenInfo request
	GetTokenInfoWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*GetTokenInfoResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// DescribeUser request
	DescribeUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DescribeUserResponse, error)

	// PatchUser request  with any body
	PatchUserWithBodyWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)

	PatchUserWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)
}

type GetOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// the subnets from where the stack feature can access to
		Outboundports *[]OutboundResponse `json:"outboundports,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutboundportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOutboundportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutboundportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// the subnets from where the stack feature can access to
		Outboundports *[]OutboundResponse `json:"outboundports,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAllowlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// the subnets from where the stack feature is accessible from
		Subnets *[]string `json:"subnets,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAllowlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAllowlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]App `json:"apps,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]App `json:"apps,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListAppsVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InstallAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UninstallAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UninstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppClassicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchAppClassicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppClassicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapabilitiesInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSelfStorageLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SelfStorageLocations []SelfStorageLocationInfo `json:"selfStorageLocations"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListSelfStorageLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSelfStorageLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSelfStorageLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SelfStorageLocationInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSelfStorageLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSelfStorageLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationPolicy
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeSelfStorageLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeSelfStorageLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeSelfStorageLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationPrefixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationPrefix
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationPrefixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationPrefixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationServiceAccountsResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentInfo `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RetryDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentStatus `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentInfo `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppFeatureEnablementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppFeatureEnablement
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppFeatureEnablementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppFeatureEnablementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppFeatureEnablementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AppFeatureEnablement
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetAppFeatureEnablementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppFeatureEnablementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Indexes *[]IndexResponse `json:"indexes,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *IndexInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Indexinfo *IndexResponse `json:"indexinfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetIndexInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchIndexInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchIndexInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchIndexInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHECsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		HttpEventCollectors *[]HecInfo `json:"http_event_collectors,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListHECsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHECsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		HttpEventCollector *HecSpec `json:"http-event-collector,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteHecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeHecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		HttpEventCollector *HecInfo `json:"http-event-collector,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeHecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeHecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLimitsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAllLimitsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLimitsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLimitsConfigDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LimitStanza
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAllLimitsConfigDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLimitsConfigDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsConfigDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LimitStanza
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLimitsConfigDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsConfigDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetKeyLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMaintenanceWindowsSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListMaintenanceWindowsSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMaintenanceWindowsSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeMaintenanceWindowsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceWindowsSchedule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeMaintenanceWindowsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeMaintenanceWindowsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditMaintenanceWindowsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AuditMaintenanceWindowsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditMaintenanceWindowsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *AppPermsList `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribePermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPerms
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribePermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribePermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchPermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidatePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeEligibilityPrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ValidatePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidatePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdatePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnablePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *EnablePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r EnablePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnablePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RestartResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestartStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ShcStatus *[]RestartStatus `json:"shcStatus,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RestartStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Roles *[]RolesResponse `json:"roles,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRoleInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchRoleInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRoleInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *StackStatus `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokens *[]TokenInfo `json:"tokens,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Users *[]UsersResponse `json:"users,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOutboundportsWithResponse request returning *GetOutboundportsResponse
func (c *ClientWithResponses) GetOutboundportsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetOutboundportsResponse, error) {
	rsp, err := c.GetOutboundports(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutboundportsResponse(rsp)
}

// AddOutboundportsWithBodyWithResponse request with arbitrary body returning *AddOutboundportsResponse
func (c *ClientWithResponses) AddOutboundportsWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error) {
	rsp, err := c.AddOutboundportsWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOutboundportsResponse(rsp)
}

func (c *ClientWithResponses) AddOutboundportsWithResponse(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error) {
	rsp, err := c.AddOutboundports(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOutboundportsResponse(rsp)
}

// DeleteOutboundportWithBodyWithResponse request with arbitrary body returning *DeleteOutboundportResponse
func (c *ClientWithResponses) DeleteOutboundportWithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error) {
	rsp, err := c.DeleteOutboundportWithBody(ctx, stack, port, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundportResponse(rsp)
}

func (c *ClientWithResponses) DeleteOutboundportWithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error) {
	rsp, err := c.DeleteOutboundport(ctx, stack, port, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundportResponse(rsp)
}

// DescribeOutboundportsWithResponse request returning *DescribeOutboundportsResponse
func (c *ClientWithResponses) DescribeOutboundportsWithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsResponse, error) {
	rsp, err := c.DescribeOutboundports(ctx, stack, port, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeOutboundportsResponse(rsp)
}

// DeleteSubnetsWithBodyWithResponse request with arbitrary body returning *DeleteSubnetsResponse
func (c *ClientWithResponses) DeleteSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error) {
	rsp, err := c.DeleteSubnetsWithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetsResponse(rsp)
}

func (c *ClientWithResponses) DeleteSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error) {
	rsp, err := c.DeleteSubnets(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetsResponse(rsp)
}

// DescribeAllowlistWithResponse request returning *DescribeAllowlistResponse
func (c *ClientWithResponses) DescribeAllowlistWithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistResponse, error) {
	rsp, err := c.DescribeAllowlist(ctx, stack, feature, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAllowlistResponse(rsp)
}

// AddSubnetsWithBodyWithResponse request with arbitrary body returning *AddSubnetsResponse
func (c *ClientWithResponses) AddSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error) {
	rsp, err := c.AddSubnetsWithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubnetsResponse(rsp)
}

func (c *ClientWithResponses) AddSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error) {
	rsp, err := c.AddSubnets(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubnetsResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, stack, feature, subnet, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// InstallAppWithBodyWithResponse request with arbitrary body returning *InstallAppResponse
func (c *ClientWithResponses) InstallAppWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppResponse, error) {
	rsp, err := c.InstallAppWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAppResponse(rsp)
}

// ListAppsVictoriaWithResponse request returning *ListAppsVictoriaResponse
func (c *ClientWithResponses) ListAppsVictoriaWithResponse(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*ListAppsVictoriaResponse, error) {
	rsp, err := c.ListAppsVictoria(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsVictoriaResponse(rsp)
}

// InstallAppVictoriaWithBodyWithResponse request with arbitrary body returning *InstallAppVictoriaResponse
func (c *ClientWithResponses) InstallAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppVictoriaResponse, error) {
	rsp, err := c.InstallAppVictoriaWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAppVictoriaResponse(rsp)
}

// UninstallAppVictoriaWithResponse request returning *UninstallAppVictoriaResponse
func (c *ClientWithResponses) UninstallAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppVictoriaResponse, error) {
	rsp, err := c.UninstallAppVictoria(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppVictoriaResponse(rsp)
}

// DescribeAppVictoriaWithResponse request returning *DescribeAppVictoriaResponse
func (c *ClientWithResponses) DescribeAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppVictoriaResponse, error) {
	rsp, err := c.DescribeAppVictoria(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppVictoriaResponse(rsp)
}

// PatchAppVictoriaWithBodyWithResponse request with arbitrary body returning *PatchAppVictoriaResponse
func (c *ClientWithResponses) PatchAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppVictoriaResponse, error) {
	rsp, err := c.PatchAppVictoriaWithBody(ctx, stack, app, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppVictoriaResponse(rsp)
}

// UninstallAppWithResponse request returning *UninstallAppResponse
func (c *ClientWithResponses) UninstallAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error) {
	rsp, err := c.UninstallApp(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppResponse(rsp)
}

// DescribeAppWithResponse request returning *DescribeAppResponse
func (c *ClientWithResponses) DescribeAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppResponse, error) {
	rsp, err := c.DescribeApp(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppResponse(rsp)
}

// PatchAppClassicWithBodyWithResponse request with arbitrary body returning *PatchAppClassicResponse
func (c *ClientWithResponses) PatchAppClassicWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppClassicResponse, error) {
	rsp, err := c.PatchAppClassicWithBody(ctx, stack, app, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppClassicResponse(rsp)
}

// ListCapabilitiesWithResponse request returning *ListCapabilitiesResponse
func (c *ClientWithResponses) ListCapabilitiesWithResponse(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*ListCapabilitiesResponse, error) {
	rsp, err := c.ListCapabilities(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCapabilitiesResponse(rsp)
}

// ListSelfStorageLocationsWithResponse request returning *ListSelfStorageLocationsResponse
func (c *ClientWithResponses) ListSelfStorageLocationsWithResponse(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*ListSelfStorageLocationsResponse, error) {
	rsp, err := c.ListSelfStorageLocations(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSelfStorageLocationsResponse(rsp)
}

// CreateSelfStorageLocationWithBodyWithResponse request with arbitrary body returning *CreateSelfStorageLocationResponse
func (c *ClientWithResponses) CreateSelfStorageLocationWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error) {
	rsp, err := c.CreateSelfStorageLocationWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfStorageLocationResponse(rsp)
}

func (c *ClientWithResponses) CreateSelfStorageLocationWithResponse(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error) {
	rsp, err := c.CreateSelfStorageLocation(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfStorageLocationResponse(rsp)
}

// GetSelfStorageLocationPolicyWithResponse request returning *GetSelfStorageLocationPolicyResponse
func (c *ClientWithResponses) GetSelfStorageLocationPolicyWithResponse(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPolicyResponse, error) {
	rsp, err := c.GetSelfStorageLocationPolicy(ctx, stack, bucketName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationPolicyResponse(rsp)
}

// DescribeSelfStorageLocationWithResponse request returning *DescribeSelfStorageLocationResponse
func (c *ClientWithResponses) DescribeSelfStorageLocationWithResponse(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*DescribeSelfStorageLocationResponse, error) {
	rsp, err := c.DescribeSelfStorageLocation(ctx, stack, bucketPath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeSelfStorageLocationResponse(rsp)
}

// GetSelfStorageLocationPrefixWithResponse request returning *GetSelfStorageLocationPrefixResponse
func (c *ClientWithResponses) GetSelfStorageLocationPrefixWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPrefixResponse, error) {
	rsp, err := c.GetSelfStorageLocationPrefix(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationPrefixResponse(rsp)
}

// GetSelfStorageLocationServiceAccountsWithResponse request returning *GetSelfStorageLocationServiceAccountsResponse
func (c *ClientWithResponses) GetSelfStorageLocationServiceAccountsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationServiceAccountsResponse, error) {
	rsp, err := c.GetSelfStorageLocationServiceAccounts(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationServiceAccountsResponse(rsp)
}

// RetryDeploymentWithResponse request returning *RetryDeploymentResponse
func (c *ClientWithResponses) RetryDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RetryDeploymentResponse, error) {
	rsp, err := c.RetryDeployment(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryDeploymentResponse(rsp)
}

// ListDeploymentWithResponse request returning *ListDeploymentResponse
func (c *ClientWithResponses) ListDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListDeploymentResponse, error) {
	rsp, err := c.ListDeployment(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentResponse(rsp)
}

// DescribeDeploymentWithResponse request returning *DescribeDeploymentResponse
func (c *ClientWithResponses) DescribeDeploymentWithResponse(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*DescribeDeploymentResponse, error) {
	rsp, err := c.DescribeDeployment(ctx, stack, deploymentID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeDeploymentResponse(rsp)
}

// DescribeAppFeatureEnablementWithResponse request returning *DescribeAppFeatureEnablementResponse
func (c *ClientWithResponses) DescribeAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*DescribeAppFeatureEnablementResponse, error) {
	rsp, err := c.DescribeAppFeatureEnablement(ctx, stack, appGroup, featureName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppFeatureEnablementResponse(rsp)
}

// SetAppFeatureEnablementWithBodyWithResponse request with arbitrary body returning *SetAppFeatureEnablementResponse
func (c *ClientWithResponses) SetAppFeatureEnablementWithBodyWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error) {
	rsp, err := c.SetAppFeatureEnablementWithBody(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppFeatureEnablementResponse(rsp)
}

func (c *ClientWithResponses) SetAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error) {
	rsp, err := c.SetAppFeatureEnablement(ctx, stack, appGroup, featureName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppFeatureEnablementResponse(rsp)
}

// ListIndexesWithResponse request returning *ListIndexesResponse
func (c *ClientWithResponses) ListIndexesWithResponse(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error) {
	rsp, err := c.ListIndexes(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexesResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// DeleteIndexWithBodyWithResponse request with arbitrary body returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndexWithBody(ctx, stack, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, stack, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// GetIndexInfoWithResponse request returning *GetIndexInfoResponse
func (c *ClientWithResponses) GetIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*GetIndexInfoResponse, error) {
	rsp, err := c.GetIndexInfo(ctx, stack, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexInfoResponse(rsp)
}

// PatchIndexInfoWithBodyWithResponse request with arbitrary body returning *PatchIndexInfoResponse
func (c *ClientWithResponses) PatchIndexInfoWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error) {
	rsp, err := c.PatchIndexInfoWithBody(ctx, stack, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchIndexInfoResponse(rsp)
}

func (c *ClientWithResponses) PatchIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error) {
	rsp, err := c.PatchIndexInfo(ctx, stack, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchIndexInfoResponse(rsp)
}

// ListHECsWithResponse request returning *ListHECsResponse
func (c *ClientWithResponses) ListHECsWithResponse(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*ListHECsResponse, error) {
	rsp, err := c.ListHECs(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHECsResponse(rsp)
}

// CreateHECWithBodyWithResponse request with arbitrary body returning *CreateHECResponse
func (c *ClientWithResponses) CreateHECWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHECResponse, error) {
	rsp, err := c.CreateHECWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHECResponse(rsp)
}

func (c *ClientWithResponses) CreateHECWithResponse(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHECResponse, error) {
	rsp, err := c.CreateHEC(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHECResponse(rsp)
}

// DeleteHecWithBodyWithResponse request with arbitrary body returning *DeleteHecResponse
func (c *ClientWithResponses) DeleteHecWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error) {
	rsp, err := c.DeleteHecWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHecResponse(rsp)
}

func (c *ClientWithResponses) DeleteHecWithResponse(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error) {
	rsp, err := c.DeleteHec(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHecResponse(rsp)
}

// DescribeHecWithResponse request returning *DescribeHecResponse
func (c *ClientWithResponses) DescribeHecWithResponse(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*DescribeHecResponse, error) {
	rsp, err := c.DescribeHec(ctx, stack, hec, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeHecResponse(rsp)
}

// PatchHECWithBodyWithResponse request with arbitrary body returning *PatchHECResponse
func (c *ClientWithResponses) PatchHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchHECResponse, error) {
	rsp, err := c.PatchHECWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchHECResponse(rsp)
}

func (c *ClientWithResponses) PatchHECWithResponse(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchHECResponse, error) {
	rsp, err := c.PatchHEC(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchHECResponse(rsp)
}

// UpdateHECWithBodyWithResponse request with arbitrary body returning *UpdateHECResponse
func (c *ClientWithResponses) UpdateHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error) {
	rsp, err := c.UpdateHECWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHECResponse(rsp)
}

func (c *ClientWithResponses) UpdateHECWithResponse(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error) {
	rsp, err := c.UpdateHEC(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHECResponse(rsp)
}

// GetAllLimitsConfigWithResponse request returning *GetAllLimitsConfigResponse
func (c *ClientWithResponses) GetAllLimitsConfigWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigResponse, error) {
	rsp, err := c.GetAllLimitsConfig(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLimitsConfigResponse(rsp)
}

// GetAllLimitsConfigDefaultsWithResponse request returning *GetAllLimitsConfigDefaultsResponse
func (c *ClientWithResponses) GetAllLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigDefaultsResponse, error) {
	rsp, err := c.GetAllLimitsConfigDefaults(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLimitsConfigDefaultsResponse(rsp)
}

// GetLimitConfigWithResponse request returning *GetLimitConfigResponse
func (c *ClientWithResponses) GetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitConfigResponse, error) {
	rsp, err := c.GetLimitConfig(ctx, stack, stanza, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitConfigResponse(rsp)
}

// AddLimitConfigWithBodyWithResponse request with arbitrary body returning *AddLimitConfigResponse
func (c *ClientWithResponses) AddLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error) {
	rsp, err := c.AddLimitConfigWithBody(ctx, stack, stanza, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLimitConfigResponse(rsp)
}

func (c *ClientWithResponses) AddLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error) {
	rsp, err := c.AddLimitConfig(ctx, stack, stanza, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLimitConfigResponse(rsp)
}

// GetLimitsConfigDefaultsWithResponse request returning *GetLimitsConfigDefaultsResponse
func (c *ClientWithResponses) GetLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitsConfigDefaultsResponse, error) {
	rsp, err := c.GetLimitsConfigDefaults(ctx, stack, stanza, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsConfigDefaultsResponse(rsp)
}

// ResetLimitConfigWithBodyWithResponse request with arbitrary body returning *ResetLimitConfigResponse
func (c *ClientWithResponses) ResetLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error) {
	rsp, err := c.ResetLimitConfigWithBody(ctx, stack, stanza, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetLimitConfigResponse(rsp)
}

func (c *ClientWithResponses) ResetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error) {
	rsp, err := c.ResetLimitConfig(ctx, stack, stanza, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetLimitConfigResponse(rsp)
}

// GetKeyLimitConfigWithResponse request returning *GetKeyLimitConfigResponse
func (c *ClientWithResponses) GetKeyLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*GetKeyLimitConfigResponse, error) {
	rsp, err := c.GetKeyLimitConfig(ctx, stack, stanza, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyLimitConfigResponse(rsp)
}

// ListMaintenanceWindowsSchedulesWithResponse request returning *ListMaintenanceWindowsSchedulesResponse
func (c *ClientWithResponses) ListMaintenanceWindowsSchedulesWithResponse(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*ListMaintenanceWindowsSchedulesResponse, error) {
	rsp, err := c.ListMaintenanceWindowsSchedules(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMaintenanceWindowsSchedulesResponse(rsp)
}

// DescribeMaintenanceWindowsScheduleWithResponse request returning *DescribeMaintenanceWindowsScheduleResponse
func (c *ClientWithResponses) DescribeMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsScheduleResponse, error) {
	rsp, err := c.DescribeMaintenanceWindowsSchedule(ctx, stack, scheduleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeMaintenanceWindowsScheduleResponse(rsp)
}

// AuditMaintenanceWindowsScheduleWithResponse request returning *AuditMaintenanceWindowsScheduleResponse
func (c *ClientWithResponses) AuditMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*AuditMaintenanceWindowsScheduleResponse, error) {
	rsp, err := c.AuditMaintenanceWindowsSchedule(ctx, stack, scheduleID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditMaintenanceWindowsScheduleResponse(rsp)
}

// ListPermissionsAppsWithResponse request returning *ListPermissionsAppsResponse
func (c *ClientWithResponses) ListPermissionsAppsWithResponse(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*ListPermissionsAppsResponse, error) {
	rsp, err := c.ListPermissionsApps(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsAppsResponse(rsp)
}

// DescribePermissionsAppsWithResponse request returning *DescribePermissionsAppsResponse
func (c *ClientWithResponses) DescribePermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribePermissionsAppsResponse, error) {
	rsp, err := c.DescribePermissionsApps(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribePermissionsAppsResponse(rsp)
}

// PatchPermissionsAppsWithBodyWithResponse request with arbitrary body returning *PatchPermissionsAppsResponse
func (c *ClientWithResponses) PatchPermissionsAppsWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error) {
	rsp, err := c.PatchPermissionsAppsWithBody(ctx, stack, app, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPermissionsAppsResponse(rsp)
}

func (c *ClientWithResponses) PatchPermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error) {
	rsp, err := c.PatchPermissionsApps(ctx, stack, app, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPermissionsAppsResponse(rsp)
}

// ValidatePrivateConnectivityWithResponse request returning *ValidatePrivateConnectivityResponse
func (c *ClientWithResponses) ValidatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ValidatePrivateConnectivityResponse, error) {
	rsp, err := c.ValidatePrivateConnectivity(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePrivateConnectivityResponse(rsp)
}

// DescribePrivateConnectivityWithResponse request returning *DescribePrivateConnectivityResponse
func (c *ClientWithResponses) DescribePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribePrivateConnectivityResponse, error) {
	rsp, err := c.DescribePrivateConnectivity(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribePrivateConnectivityResponse(rsp)
}

// UpdatePrivateConnectivityWithBodyWithResponse request with arbitrary body returning *UpdatePrivateConnectivityResponse
func (c *ClientWithResponses) UpdatePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error) {
	rsp, err := c.UpdatePrivateConnectivityWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateConnectivityResponse(rsp)
}

func (c *ClientWithResponses) UpdatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error) {
	rsp, err := c.UpdatePrivateConnectivity(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateConnectivityResponse(rsp)
}

// EnablePrivateConnectivityWithBodyWithResponse request with arbitrary body returning *EnablePrivateConnectivityResponse
func (c *ClientWithResponses) EnablePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error) {
	rsp, err := c.EnablePrivateConnectivityWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePrivateConnectivityResponse(rsp)
}

func (c *ClientWithResponses) EnablePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error) {
	rsp, err := c.EnablePrivateConnectivity(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePrivateConnectivityResponse(rsp)
}

// RestartStackWithResponse request returning *RestartStackResponse
func (c *ClientWithResponses) RestartStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStackResponse, error) {
	rsp, err := c.RestartStack(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartStackResponse(rsp)
}

// RestartStatusWithResponse request returning *RestartStatusResponse
func (c *ClientWithResponses) RestartStatusWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStatusResponse, error) {
	rsp, err := c.RestartStatus(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartStatusResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, stack, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, stack, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// DescribeRoleWithResponse request returning *DescribeRoleResponse
func (c *ClientWithResponses) DescribeRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DescribeRoleResponse, error) {
	rsp, err := c.DescribeRole(ctx, stack, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeRoleResponse(rsp)
}

// PatchRoleInfoWithBodyWithResponse request with arbitrary body returning *PatchRoleInfoResponse
func (c *ClientWithResponses) PatchRoleInfoWithBodyWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error) {
	rsp, err := c.PatchRoleInfoWithBody(ctx, stack, roleName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleInfoResponse(rsp)
}

func (c *ClientWithResponses) PatchRoleInfoWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error) {
	rsp, err := c.PatchRoleInfo(ctx, stack, roleName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleInfoResponse(rsp)
}

// DescribeStackWithResponse request returning *DescribeStackResponse
func (c *ClientWithResponses) DescribeStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeStackResponse, error) {
	rsp, err := c.DescribeStack(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeStackResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, stack, tokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenInfoWithResponse request returning *GetTokenInfoResponse
func (c *ClientWithResponses) GetTokenInfoWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*GetTokenInfoResponse, error) {
	rsp, err := c.GetTokenInfo(ctx, stack, tokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenInfoResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, stack, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, stack, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// DescribeUserWithResponse request returning *DescribeUserResponse
func (c *ClientWithResponses) DescribeUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DescribeUserResponse, error) {
	rsp, err := c.DescribeUser(ctx, stack, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeUserResponse(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserResponse
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUserWithBody(ctx, stack, userName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

func (c *ClientWithResponses) PatchUserWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUser(ctx, stack, userName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

// ParseGetOutboundportsResponse parses an HTTP response from a GetOutboundportsWithResponse call
func ParseGetOutboundportsResponse(rsp *http.Response) (*GetOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// the subnets from where the stack feature can access to
			Outboundports *[]OutboundResponse `json:"outboundports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddOutboundportsResponse parses an HTTP response from a AddOutboundportsWithResponse call
func ParseAddOutboundportsResponse(rsp *http.Response) (*AddOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteOutboundportResponse parses an HTTP response from a DeleteOutboundportWithResponse call
func ParseDeleteOutboundportResponse(rsp *http.Response) (*DeleteOutboundportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutboundportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeOutboundportsResponse parses an HTTP response from a DescribeOutboundportsWithResponse call
func ParseDescribeOutboundportsResponse(rsp *http.Response) (*DescribeOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// the subnets from where the stack feature can access to
			Outboundports *[]OutboundResponse `json:"outboundports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubnetsResponse parses an HTTP response from a DeleteSubnetsWithResponse call
func ParseDeleteSubnetsResponse(rsp *http.Response) (*DeleteSubnetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAllowlistResponse parses an HTTP response from a DescribeAllowlistWithResponse call
func ParseDescribeAllowlistResponse(rsp *http.Response) (*DescribeAllowlistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAllowlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// the subnets from where the stack feature is accessible from
			Subnets *[]string `json:"subnets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddSubnetsResponse parses an HTTP response from a AddSubnetsWithResponse call
func ParseAddSubnetsResponse(rsp *http.Response) (*AddSubnetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]App `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInstallAppResponse parses an HTTP response from a InstallAppWithResponse call
func ParseInstallAppResponse(rsp *http.Response) (*InstallAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListAppsVictoriaResponse parses an HTTP response from a ListAppsVictoriaWithResponse call
func ParseListAppsVictoriaResponse(rsp *http.Response) (*ListAppsVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAppsVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]App `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInstallAppVictoriaResponse parses an HTTP response from a InstallAppVictoriaWithResponse call
func ParseInstallAppVictoriaResponse(rsp *http.Response) (*InstallAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InstallAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppVictoriaResponse parses an HTTP response from a UninstallAppVictoriaWithResponse call
func ParseUninstallAppVictoriaResponse(rsp *http.Response) (*UninstallAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppVictoriaResponse parses an HTTP response from a DescribeAppVictoriaWithResponse call
func ParseDescribeAppVictoriaResponse(rsp *http.Response) (*DescribeAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchAppVictoriaResponse parses an HTTP response from a PatchAppVictoriaWithResponse call
func ParsePatchAppVictoriaResponse(rsp *http.Response) (*PatchAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppResponse parses an HTTP response from a UninstallAppWithResponse call
func ParseUninstallAppResponse(rsp *http.Response) (*UninstallAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppResponse parses an HTTP response from a DescribeAppWithResponse call
func ParseDescribeAppResponse(rsp *http.Response) (*DescribeAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchAppClassicResponse parses an HTTP response from a PatchAppClassicWithResponse call
func ParsePatchAppClassicResponse(rsp *http.Response) (*PatchAppClassicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchAppClassicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCapabilitiesResponse parses an HTTP response from a ListCapabilitiesWithResponse call
func ParseListCapabilitiesResponse(rsp *http.Response) (*ListCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapabilitiesInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListSelfStorageLocationsResponse parses an HTTP response from a ListSelfStorageLocationsWithResponse call
func ParseListSelfStorageLocationsResponse(rsp *http.Response) (*ListSelfStorageLocationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListSelfStorageLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SelfStorageLocations []SelfStorageLocationInfo `json:"selfStorageLocations"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSelfStorageLocationResponse parses an HTTP response from a CreateSelfStorageLocationWithResponse call
func ParseCreateSelfStorageLocationResponse(rsp *http.Response) (*CreateSelfStorageLocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSelfStorageLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SelfStorageLocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationPolicyResponse parses an HTTP response from a GetSelfStorageLocationPolicyWithResponse call
func ParseGetSelfStorageLocationPolicyResponse(rsp *http.Response) (*GetSelfStorageLocationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeSelfStorageLocationResponse parses an HTTP response from a DescribeSelfStorageLocationWithResponse call
func ParseDescribeSelfStorageLocationResponse(rsp *http.Response) (*DescribeSelfStorageLocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeSelfStorageLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationPrefixResponse parses an HTTP response from a GetSelfStorageLocationPrefixWithResponse call
func ParseGetSelfStorageLocationPrefixResponse(rsp *http.Response) (*GetSelfStorageLocationPrefixResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationPrefixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationPrefix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationServiceAccountsResponse parses an HTTP response from a GetSelfStorageLocationServiceAccountsWithResponse call
func ParseGetSelfStorageLocationServiceAccountsResponse(rsp *http.Response) (*GetSelfStorageLocationServiceAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationServiceAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRetryDeploymentResponse parses an HTTP response from a RetryDeploymentWithResponse call
func ParseRetryDeploymentResponse(rsp *http.Response) (*RetryDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RetryDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentInfo `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListDeploymentResponse parses an HTTP response from a ListDeploymentWithResponse call
func ParseListDeploymentResponse(rsp *http.Response) (*ListDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentStatus `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeDeploymentResponse parses an HTTP response from a DescribeDeploymentWithResponse call
func ParseDescribeDeploymentResponse(rsp *http.Response) (*DescribeDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentInfo `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppFeatureEnablementResponse parses an HTTP response from a DescribeAppFeatureEnablementWithResponse call
func ParseDescribeAppFeatureEnablementResponse(rsp *http.Response) (*DescribeAppFeatureEnablementResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppFeatureEnablementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppFeatureEnablement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetAppFeatureEnablementResponse parses an HTTP response from a SetAppFeatureEnablementWithResponse call
func ParseSetAppFeatureEnablementResponse(rsp *http.Response) (*SetAppFeatureEnablementResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetAppFeatureEnablementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AppFeatureEnablement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIndexesResponse parses an HTTP response from a ListIndexesWithResponse call
func ParseListIndexesResponse(rsp *http.Response) (*ListIndexesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Indexes *[]IndexResponse `json:"indexes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest IndexInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIndexInfoResponse parses an HTTP response from a GetIndexInfoWithResponse call
func ParseGetIndexInfoResponse(rsp *http.Response) (*GetIndexInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetIndexInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Indexinfo *IndexResponse `json:"indexinfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchIndexInfoResponse parses an HTTP response from a PatchIndexInfoWithResponse call
func ParsePatchIndexInfoResponse(rsp *http.Response) (*PatchIndexInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchIndexInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListHECsResponse parses an HTTP response from a ListHECsWithResponse call
func ParseListHECsResponse(rsp *http.Response) (*ListHECsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListHECsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			HttpEventCollectors *[]HecInfo `json:"http_event_collectors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHECResponse parses an HTTP response from a CreateHECWithResponse call
func ParseCreateHECResponse(rsp *http.Response) (*CreateHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			HttpEventCollector *HecSpec `json:"http-event-collector,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHecResponse parses an HTTP response from a DeleteHecWithResponse call
func ParseDeleteHecResponse(rsp *http.Response) (*DeleteHecResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteHecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeHecResponse parses an HTTP response from a DescribeHecWithResponse call
func ParseDescribeHecResponse(rsp *http.Response) (*DescribeHecResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeHecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			HttpEventCollector *HecInfo `json:"http-event-collector,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchHECResponse parses an HTTP response from a PatchHECWithResponse call
func ParsePatchHECResponse(rsp *http.Response) (*PatchHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateHECResponse parses an HTTP response from a UpdateHECWithResponse call
func ParseUpdateHECResponse(rsp *http.Response) (*UpdateHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLimitsConfigResponse parses an HTTP response from a GetAllLimitsConfigWithResponse call
func ParseGetAllLimitsConfigResponse(rsp *http.Response) (*GetAllLimitsConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAllLimitsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLimitsConfigDefaultsResponse parses an HTTP response from a GetAllLimitsConfigDefaultsWithResponse call
func ParseGetAllLimitsConfigDefaultsResponse(rsp *http.Response) (*GetAllLimitsConfigDefaultsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAllLimitsConfigDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LimitStanza
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLimitConfigResponse parses an HTTP response from a GetLimitConfigWithResponse call
func ParseGetLimitConfigResponse(rsp *http.Response) (*GetLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddLimitConfigResponse parses an HTTP response from a AddLimitConfigWithResponse call
func ParseAddLimitConfigResponse(rsp *http.Response) (*AddLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLimitsConfigDefaultsResponse parses an HTTP response from a GetLimitsConfigDefaultsWithResponse call
func ParseGetLimitsConfigDefaultsResponse(rsp *http.Response) (*GetLimitsConfigDefaultsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsConfigDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LimitStanza
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetLimitConfigResponse parses an HTTP response from a ResetLimitConfigWithResponse call
func ParseResetLimitConfigResponse(rsp *http.Response) (*ResetLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeyLimitConfigResponse parses an HTTP response from a GetKeyLimitConfigWithResponse call
func ParseGetKeyLimitConfigResponse(rsp *http.Response) (*GetKeyLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetKeyLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMaintenanceWindowsSchedulesResponse parses an HTTP response from a ListMaintenanceWindowsSchedulesWithResponse call
func ParseListMaintenanceWindowsSchedulesResponse(rsp *http.Response) (*ListMaintenanceWindowsSchedulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListMaintenanceWindowsSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeMaintenanceWindowsScheduleResponse parses an HTTP response from a DescribeMaintenanceWindowsScheduleWithResponse call
func ParseDescribeMaintenanceWindowsScheduleResponse(rsp *http.Response) (*DescribeMaintenanceWindowsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeMaintenanceWindowsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceWindowsSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAuditMaintenanceWindowsScheduleResponse parses an HTTP response from a AuditMaintenanceWindowsScheduleWithResponse call
func ParseAuditMaintenanceWindowsScheduleResponse(rsp *http.Response) (*AuditMaintenanceWindowsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuditMaintenanceWindowsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPermissionsAppsResponse parses an HTTP response from a ListPermissionsAppsWithResponse call
func ParseListPermissionsAppsResponse(rsp *http.Response) (*ListPermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *AppPermsList `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribePermissionsAppsResponse parses an HTTP response from a DescribePermissionsAppsWithResponse call
func ParseDescribePermissionsAppsResponse(rsp *http.Response) (*DescribePermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribePermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPerms
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchPermissionsAppsResponse parses an HTTP response from a PatchPermissionsAppsWithResponse call
func ParsePatchPermissionsAppsResponse(rsp *http.Response) (*PatchPermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchPermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseValidatePrivateConnectivityResponse parses an HTTP response from a ValidatePrivateConnectivityWithResponse call
func ParseValidatePrivateConnectivityResponse(rsp *http.Response) (*ValidatePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ValidatePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeEligibilityPrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribePrivateConnectivityResponse parses an HTTP response from a DescribePrivateConnectivityWithResponse call
func ParseDescribePrivateConnectivityResponse(rsp *http.Response) (*DescribePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePrivateConnectivityResponse parses an HTTP response from a UpdatePrivateConnectivityWithResponse call
func ParseUpdatePrivateConnectivityResponse(rsp *http.Response) (*UpdatePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdatePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEnablePrivateConnectivityResponse parses an HTTP response from a EnablePrivateConnectivityWithResponse call
func ParseEnablePrivateConnectivityResponse(rsp *http.Response) (*EnablePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EnablePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EnablePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestartStackResponse parses an HTTP response from a RestartStackWithResponse call
func ParseRestartStackResponse(rsp *http.Response) (*RestartStackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestartStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RestartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestartStatusResponse parses an HTTP response from a RestartStatusWithResponse call
func ParseRestartStatusResponse(rsp *http.Response) (*RestartStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestartStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ShcStatus *[]RestartStatus `json:"shcStatus,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Roles *[]RolesResponse `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeRoleResponse parses an HTTP response from a DescribeRoleWithResponse call
func ParseDescribeRoleResponse(rsp *http.Response) (*DescribeRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchRoleInfoResponse parses an HTTP response from a PatchRoleInfoWithResponse call
func ParsePatchRoleInfoResponse(rsp *http.Response) (*PatchRoleInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchRoleInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeStackResponse parses an HTTP response from a DescribeStackWithResponse call
func ParseDescribeStackResponse(rsp *http.Response) (*DescribeStackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *StackStatus `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokens *[]TokenInfo `json:"tokens,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenInfoResponse parses an HTTP response from a GetTokenInfoWithResponse call
func ParseGetTokenInfoResponse(rsp *http.Response) (*GetTokenInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Users *[]UsersResponse `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeUserResponse parses an HTTP response from a DescribeUserWithResponse call
func ParseDescribeUserResponse(rsp *http.Response) (*DescribeUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchUserResponse parses an HTTP response from a PatchUserWithResponse call
func ParsePatchUserResponse(rsp *http.Response) (*PatchUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

