// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package v2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
)

// an splunk installed on the stack
type App struct {
	AppID                      *string `json:"appID,omitempty"`
	Label                      *string `json:"label,omitempty"`
	Name                       string  `json:"name"`
	Package                    *string `json:"package,omitempty"`
	SplunkbaseID               *string `json:"splunkbaseID,omitempty"`
	StateChangeRequiresRestart *bool   `json:"stateChangeRequiresRestart,omitempty"`
	Status                     string  `json:"status"`
	Version                    *string `json:"version,omitempty"`
}

// AppFeatureEnablement defines model for AppFeatureEnablement.
type AppFeatureEnablement struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// App Permissions
type AppPerms struct {
	Name  string             `json:"name"`
	Perms AppPermsProperties `json:"perms"`
}

// AppPermsList defines model for AppPermsList.
type AppPermsList struct {
	Apps *[]AppPerms `json:"apps,omitempty"`
}

// AppPermsProperties defines model for AppPermsProperties.
type AppPermsProperties struct {
	Read  *[]string `json:"read,omitempty"`
	Write *[]string `json:"write,omitempty"`
}

// capabilities list
type CapabilitiesInfo struct {
	GrantableCapabilities *[]string `json:"grantableCapabilities,omitempty"`
	SystemCapabilities    *[]string `json:"systemCapabilities,omitempty"`
}

// ChangePythonVersionRequest defines model for ChangePythonVersionRequest.
type ChangePythonVersionRequest struct {
	PythonVersion *string `json:"pythonVersion,omitempty"`
}

// ID for pairing Splunk Cloud stack with Observability organization
type CreateEcSsoPairingResponse struct {
	PairingId *string `json:"pairingId,omitempty"`
}

// Create user request body
type CreateUserRequest struct {
	CreateRole      *bool     `json:"createRole,omitempty"`
	DefaultApp      *string   `json:"defaultApp,omitempty"`
	Email           *string   `json:"email,omitempty"`
	ForceChangePass *bool     `json:"forceChangePass,omitempty"`
	FullName        *string   `json:"fullName,omitempty"`
	Name            string    `json:"name"`
	Password        string    `json:"password"`
	Roles           *[]string `json:"roles,omitempty"`
}

// DeploymentInfo defines model for DeploymentInfo.
type DeploymentInfo struct {

	// the id of the latest deployment task
	Id string `json:"id"`

	// the status of the last deployment task, possible values are new, completed, pending, running, failed.
	Status *string `json:"status,omitempty"`

	// timestamp of the latest deployment task
	Timestamp *string `json:"timestamp,omitempty"`
}

// DeploymentStatus defines model for DeploymentStatus.
type DeploymentStatus struct {
	LastDeployment DeploymentInfo `json:"lastDeployment"`
}

// DescribeEligibilityPrivateConnectivity defines model for DescribeEligibilityPrivateConnectivity.
type DescribeEligibilityPrivateConnectivity struct {
	Eligible *bool   `json:"eligible,omitempty"`
	Reason   *string `json:"reason,omitempty"`
}

// DescribeManagedGlueResources defines model for DescribeManagedGlueResources.
type DescribeManagedGlueResources struct {
	ManagedGlueResources *[]ManagedGlueResources `json:"managedGlueResources,omitempty"`
	Status               *string                 `json:"status,omitempty"`
}

// DescribePrivateConnectivity defines model for DescribePrivateConnectivity.
type DescribePrivateConnectivity struct {
	Endpoints *[]PrivateConnectivityEndpoints `json:"endpoints,omitempty"`
}

// DescribeWorkflowResponseObject defines model for DescribeWorkflowResponseObject.
type DescribeWorkflowResponseObject struct {
	CreatedAt  *string `json:"createdAt,omitempty"`
	FinishedAt *string `json:"finishedAt,omitempty"`
	Name       *string `json:"name,omitempty"`
	StartedAt  *string `json:"startedAt,omitempty"`
	Status     *string `json:"status,omitempty"`
}

// EmekKeyUploadResponse defines model for EmekKeyUploadResponse.
type EmekKeyUploadResponse struct {
	Message string `json:"message"`
}

// EmekPolicy defines model for EmekPolicy.
type EmekPolicy struct {
	Message string                 `json:"message"`
	Policy  map[string]interface{} `json:"policy"`
	Region  string                 `json:"region"`
}

// CO2 spec value of the o11y key
type EnableObservabilityCapabilitiesResponse struct {
	CentralizedRBACEnabled *bool `json:"centralizedRBACEnabled,omitempty"`
}

// EnablePrivateConnectivity defines model for EnablePrivateConnectivity.
type EnablePrivateConnectivity struct {
	CustomerAccountIds *[]string                    `json:"customerAccountIds,omitempty"`
	Feature            *PrivateConnectivityFeatures `json:"feature,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// Status for pairing Splunk Cloud stack with Observability organization
type GetEcSsoPairingStatusResponse struct {
	PairingId *string `json:"pairingId,omitempty"`
	Status    *string `json:"status,omitempty"`
}

// HecInfo defines model for HecInfo.
type HecInfo struct {
	Spec  *HecSpec `json:"spec,omitempty"`
	Token *string  `json:"token,omitempty"`
}

// HecSpec defines model for HecSpec.
type HecSpec struct {
	AllowedIndexes    *[]string `json:"allowedIndexes,omitempty"`
	DefaultHost       *string   `json:"defaultHost,omitempty"`
	DefaultIndex      *string   `json:"defaultIndex,omitempty"`
	DefaultSource     *string   `json:"defaultSource,omitempty"`
	DefaultSourcetype *string   `json:"defaultSourcetype,omitempty"`
	Disabled          *bool     `json:"disabled,omitempty"`
	Name              string    `json:"name"`
	Token             *string   `json:"token,omitempty"`
	UseAck            *bool     `json:"useAck,omitempty"`
}

// ImportedRolesInfo defines model for ImportedRolesInfo.
type ImportedRolesInfo struct {
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Roles *[]string `json:"roles,omitempty"`
}

// IndexInfo defines model for IndexInfo.
type IndexInfo struct {
	Datatype                    *string `json:"datatype,omitempty"`
	MaxDataSizeMB               *int64  `json:"maxDataSizeMB,omitempty"`
	Name                        string  `json:"name"`
	SearchableDays              *int64  `json:"searchableDays,omitempty"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *int64  `json:"splunkArchivalRetentionDays,omitempty"`
}

// IndexResponse defines model for IndexResponse.
type IndexResponse struct {
	Datatype                    string  `json:"datatype"`
	MaxDataSizeMB               uint64  `json:"maxDataSizeMB"`
	Name                        string  `json:"name"`
	SearchableDays              uint64  `json:"searchableDays"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *uint64 `json:"splunkArchivalRetentionDays,omitempty"`
	TotalEventCount             *string `json:"totalEventCount,omitempty"`
	TotalRawSizeMB              *string `json:"totalRawSizeMB,omitempty"`
}

// LimitConfigurationInfo defines model for LimitConfigurationInfo.
type LimitConfigurationInfo struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`
}

// LimitConfigurationResponse defines model for LimitConfigurationResponse.
type LimitConfigurationResponse struct {
	Settings *[]interface{} `json:"settings,omitempty"`
}

// LimitResetSettingsList defines model for LimitResetSettingsList.
type LimitResetSettingsList struct {
	Settings *[]interface{} `json:"settings,omitempty"`
}

// LimitSetting defines model for LimitSetting.
type LimitSetting struct {
	DefaultValue *float64 `json:"defaultValue,omitempty"`
	MaxValue     *float64 `json:"maxValue,omitempty"`
	MinValue     *float64 `json:"minValue,omitempty"`
	Setting      *string  `json:"setting,omitempty"`
}

// LimitStanza defines model for LimitStanza.
type LimitStanza struct {
	Settings *[]LimitSetting `json:"settings,omitempty"`
	Stanza   *string         `json:"stanza,omitempty"`
}

// MaintenanceWindowsAuditResponse defines model for MaintenanceWindowsAuditResponse.
type MaintenanceWindowsAuditResponse struct {
	Audits []MaintenanceWindowsSchedule `json:"audits"`
}

// MaintenanceWindowsChangeFreezeRequest defines model for MaintenanceWindowsChangeFreezeRequest.
type MaintenanceWindowsChangeFreezeRequest struct {
	CustomerInitiatedFreezes []MaintenanceWindowsCustomerInitiatedFreezeRequest `json:"customerInitiatedFreezes"`
}

// MaintenanceWindowsChangeFreezeResponse defines model for MaintenanceWindowsChangeFreezeResponse.
type MaintenanceWindowsChangeFreezeResponse struct {
	CustomerInitiatedFreezes []MaintenanceWindowsCustomerInitiatedFreezeResponse `json:"customerInitiatedFreezes"`
	SplunkInitiatedFreezes   []MaintenanceWindowsSplunkInitiatedFreezeResponse   `json:"splunkInitiatedFreezes"`
}

// MaintenanceWindowsCustomerInitiatedFreezeRequest defines model for MaintenanceWindowsCustomerInitiatedFreezeRequest.
type MaintenanceWindowsCustomerInitiatedFreezeRequest struct {

	// Type of changes the change freeze applies to.
	AppliesTo string `json:"appliesTo"`

	// Date (YYYY/MM/DD) when the change freeze ends.
	EndDate string `json:"endDate"`

	// Unique identifier (UUID) of the change freeze. This field should be left empty for new change freezes.
	Id *string `json:"id,omitempty"`

	// Reason for the change freeze.
	Reason string `json:"reason"`

	// Date (YYYY/MM/DD) when the change freeze starts.
	StartDate string `json:"startDate"`
}

// MaintenanceWindowsCustomerInitiatedFreezeResponse defines model for MaintenanceWindowsCustomerInitiatedFreezeResponse.
type MaintenanceWindowsCustomerInitiatedFreezeResponse struct {

	// Type of changes the change freeze applies to.
	AppliesTo string `json:"appliesTo"`

	// Time at which the change freeze was created.
	CreatedTimestamp time.Time `json:"createdTimestamp"`

	// Date (YYYY/MM/DD) when the change freeze ends.
	EndDate string `json:"endDate"`

	// UUID of the change freeze.
	Id string `json:"id"`

	// Time at which the change freeze was last modified.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Reason for the change freeze.
	Reason string `json:"reason"`

	// Date (YYYY/MM/DD) when the change freeze starts.
	StartDate string `json:"startDate"`

	// SFDC Tickets associated with the change freeze request.
	Tickets []string `json:"tickets"`
}

// MaintenanceWindowsOperation defines model for MaintenanceWindowsOperation.
type MaintenanceWindowsOperation struct {

	// List of SFDC tickets associated with the operation.
	SFDCTickets *[]string `json:"SFDCTickets,omitempty"`

	// Name of the app to be upgraded.
	AppName *string `json:"appName,omitempty"`

	// Time at which the operation ended.
	EndTime *time.Time `json:"endTime,omitempty"`

	// A map containing metadata about the operation (e.g. targetVersion, lastStatusBeforeCanceled, etc...).
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Notes for the customer.
	Notes *[]string `json:"notes,omitempty"`

	// Description of the operation.
	OperationDescription string `json:"operationDescription"`

	// Status of the operation.
	OperationStatus string `json:"operationStatus"`

	// Type of the operation.
	OperationType string `json:"operationType"`

	// Time at which the operation started.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Target version after the upgrade.
	TargetVersion *string `json:"targetVersion,omitempty"`

	// True if the operation will have no impact on the uptime of the stack.
	ZeroDowntime bool `json:"zeroDowntime"`
}

// MaintenanceWindowsPreferencesRequest defines model for MaintenanceWindowsPreferencesRequest.
type MaintenanceWindowsPreferencesRequest struct {
	ChangeFreezes MaintenanceWindowsChangeFreezeRequest `json:"changeFreezes"`

	// Version of the record.
	RecordVersion *int `json:"recordVersion,omitempty"`
}

// MaintenanceWindowsPreferencesResponse defines model for MaintenanceWindowsPreferencesResponse.
type MaintenanceWindowsPreferencesResponse struct {
	ChangeFreezes MaintenanceWindowsChangeFreezeResponse `json:"changeFreezes"`

	// Version of the record.
	RecordVersion int `json:"recordVersion"`
}

// MaintenanceWindowsResponse defines model for MaintenanceWindowsResponse.
type MaintenanceWindowsResponse struct {
	NextLink  string                       `json:"nextLink"`
	Schedules []MaintenanceWindowsSchedule `json:"schedules"`
}

// MaintenanceWindowsSchedule defines model for MaintenanceWindowsSchedule.
type MaintenanceWindowsSchedule struct {

	// The duration of the maintenance window.
	Duration string `json:"duration"`

	// Duration of the maintenance window schedule extension.
	ExtendedDuration *string `json:"extendedDuration,omitempty"`

	// Time at which the maintenance window was last modified. Format is RFC3339.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// The summary or reason for the maintenance.
	LastSummary *string `json:"lastSummary,omitempty"`

	// Time at which the maintenance window actually ended. This field is populated only after the window ends. Format is RFC3339.
	MaintenanceEndedAt *time.Time `json:"maintenanceEndedAt,omitempty"`

	// Time at which the maintenance window actually started. This field is populated only after the window begins. Format is RFC3339.
	MaintenanceStartedAt *time.Time `json:"maintenanceStartedAt,omitempty"`

	// The type of upgrade performed in the maintenance window.
	MwType     string                         `json:"mwType"`
	Operations *[]MaintenanceWindowsOperation `json:"operations,omitempty"`

	// The entity which requested the maintenance window, either the customer or Splunk.
	RequestedEntity string `json:"requestedEntity"`

	// The user who requested the maintenance window.
	RequestedUser *string `json:"requestedUser,omitempty"`

	// Time at which the maintenance window is scheduled to end. Format is RFC3339.
	ScheduleEndTimestamp *time.Time `json:"scheduleEndTimestamp,omitempty"`

	// UUID of the maintenance window.
	ScheduleId string `json:"scheduleId"`

	// Time at which the maintenance window is scheduled to begin. Format is RFC3339.
	ScheduleStartTimestamp time.Time `json:"scheduleStartTimestamp"`

	// The status of the maintenance window schedule.
	Status string `json:"status"`

	// True if the maintenance window will have no impact on the uptime of the stack.
	ZeroDowntime bool `json:"zeroDowntime"`
}

// MaintenanceWindowsSplunkInitiatedFreezeResponse defines model for MaintenanceWindowsSplunkInitiatedFreezeResponse.
type MaintenanceWindowsSplunkInitiatedFreezeResponse struct {

	// Type of changes the change freeze applies to.
	AppliesTo string `json:"appliesTo"`

	// Category of change freeze.
	Category string `json:"category"`

	// Time at which the change freeze was created.
	CreatedTimestamp time.Time `json:"createdTimestamp"`

	// Date (YYYY/MM/DD) when the change freeze ends.
	EndDate string `json:"endDate"`

	// UUID of the change freeze.
	Id string `json:"id"`

	// Time at which the change freeze was last modified.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Reason for the change freeze.
	Reason string `json:"reason"`

	// Date (YYYY/MM/DD) when the change freeze starts.
	StartDate string `json:"startDate"`

	// Tickets associated with the change freeze request.
	Tickets []string `json:"tickets"`
}

// ManagedGlueResources defines model for ManagedGlueResources.
type ManagedGlueResources struct {
	CloudProvider       string              `json:"cloudProvider"`
	Database            string              `json:"database"`
	Extra               *Extra              `json:"extra,omitempty"`
	FieldDelimiter      *string             `json:"fieldDelimiter,omitempty"`
	FileFormat          string              `json:"fileFormat"`
	LocationPrefix      string              `json:"locationPrefix"`
	PartitionProjection PartitionProjection `json:"partitionProjection"`
	SourceType          string              `json:"sourceType"`
	Table               string              `json:"table"`
}

// OutboundResponse defines model for OutboundResponse.
type OutboundResponse struct {
	DestinationRanges *[]string `json:"destinationRanges,omitempty"`
	Name              *string   `json:"name,omitempty"`
	Port              *int32    `json:"port,omitempty"`
}

// patch permissions apps body
type PatchAppPermsRequest struct {
	Read  *[]string `json:"read,omitempty"`
	Write *[]string `json:"write,omitempty"`
}

// PatchIndexInfo defines model for PatchIndexInfo.
type PatchIndexInfo struct {
	MaxDataSizeMB               *int64  `json:"maxDataSizeMB,omitempty"`
	SearchableDays              *int64  `json:"searchableDays,omitempty"`
	SelfStorageBucketPath       *string `json:"selfStorageBucketPath,omitempty"`
	SplunkArchivalRetentionDays *int64  `json:"splunkArchivalRetentionDays,omitempty"`
}

// the splunkbase app version to update.  If no version specified, the latest version will be installed.
type PatchSplunkbaseBody struct {
	Version *string `json:"version,omitempty"`
}

// Patch user request body
type PatchUserRequest struct {
	DefaultApp      *string   `json:"defaultApp,omitempty"`
	Email           *string   `json:"email,omitempty"`
	ForceChangePass *bool     `json:"forceChangePass,omitempty"`
	FullName        *string   `json:"fullName,omitempty"`
	OldPassword     *string   `json:"oldPassword,omitempty"`
	Password        *string   `json:"password,omitempty"`
	Roles           *[]string `json:"roles,omitempty"`
}

// PostRolesRequest defines model for PostRolesRequest.
type PostRolesRequest struct {
	// Embedded struct due to allOf(#/components/schemas/RolesRequest)
	RolesRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Name string `json:"name"`
}

// the app package in tgz format
type PrivateAppBody string

// PrivateConnectivityEndpoints defines model for PrivateConnectivityEndpoints.
type PrivateConnectivityEndpoints struct {
	CustomerAccountIds      *[]string `json:"customerAccountIds,omitempty"`
	Endpoint                *string   `json:"endpoint,omitempty"`
	Feature                 *string   `json:"feature,omitempty"`
	Message                 *string   `json:"message,omitempty"`
	PrivateSearchDNSRecords *[]string `json:"privateSearch-DNSRecords,omitempty"`
	Reason                  *string   `json:"reason,omitempty"`
	ResourceId              *string   `json:"resourceId,omitempty"`
	Status                  *string   `json:"status,omitempty"`
	TargetSubResource       *string   `json:"targetSubResource,omitempty"`
}

// PrivateConnectivityFeatures defines model for PrivateConnectivityFeatures.
type PrivateConnectivityFeatures []string

// PythonVersionResponse defines model for PythonVersionResponse.
type PythonVersionResponse struct {
	Message       *string `json:"message,omitempty"`
	PythonVersion *string `json:"pythonVersion,omitempty"`
}

// RestartResponse defines model for RestartResponse.
type RestartResponse struct {
	Message *string `json:"message,omitempty"`
}

// RestartStatus defines model for RestartStatus.
type RestartStatus struct {
	Captain                 *string `json:"captain,omitempty"`
	RollingRestartInitiated *bool   `json:"rollingRestartInitiated,omitempty"`
	ServiceReady            *bool   `json:"serviceReady,omitempty"`
}

// RolesInfo defines model for RolesInfo.
type RolesInfo struct {
	Capabilities       *[]string `json:"capabilities,omitempty"`
	RtSrchJobsQuota    *int      `json:"rtSrchJobsQuota,omitempty"`
	SrchDiskQuota      *int      `json:"srchDiskQuota,omitempty"`
	SrchFilter         *string   `json:"srchFilter,omitempty"`
	SrchIndexesAllowed *[]string `json:"srchIndexesAllowed,omitempty"`
	SrchIndexesDefault *[]string `json:"srchIndexesDefault,omitempty"`
	SrchJobsQuota      *int      `json:"srchJobsQuota,omitempty"`
	SrchTimeEarliest   *int      `json:"srchTimeEarliest,omitempty"`
	SrchTimeWin        *int      `json:"srchTimeWin,omitempty"`
}

// RolesRequest defines model for RolesRequest.
type RolesRequest struct {
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	CumulativeRTSrchJobsQuota *int      `json:"cumulativeRTSrchJobsQuota,omitempty"`
	CumulativeSrchJobsQuota   *int      `json:"cumulativeSrchJobsQuota,omitempty"`
	DefaultApp                *string   `json:"defaultApp,omitempty"`
	ImportedRoles             *[]string `json:"importedRoles,omitempty"`
}

// RolesResponse defines model for RolesResponse.
type RolesResponse struct {
	// Embedded fields due to inline allOf schema
	CumulativeRTSrchJobsQuota *int               `json:"cumulativeRTSrchJobsQuota,omitempty"`
	CumulativeSrchJobsQuota   *int               `json:"cumulativeSrchJobsQuota,omitempty"`
	DefaultApp                *string            `json:"defaultApp,omitempty"`
	Imported                  *ImportedRolesInfo `json:"imported,omitempty"`
	Name                      string             `json:"name"`
	// Embedded struct due to allOf(#/components/schemas/RolesInfo)
	RolesInfo `yaml:",inline"`
}

// SelfStorageLocationBody defines model for SelfStorageLocationBody.
type SelfStorageLocationBody struct {
	BucketName  string  `json:"bucketName"`
	Description *string `json:"description,omitempty"`
	Folder      *string `json:"folder,omitempty"`
	Title       string  `json:"title"`
}

// SelfStorageLocationInfo defines model for SelfStorageLocationInfo.
type SelfStorageLocationInfo struct {
	BucketName  string `json:"bucketName"`
	BucketPath  string `json:"bucketPath"`
	Description string `json:"description"`
	Folder      string `json:"folder"`
	Title       string `json:"title"`
	Uri         string `json:"uri"`
}

// SelfStorageLocationPolicy defines model for SelfStorageLocationPolicy.
type SelfStorageLocationPolicy struct {
	Message string                 `json:"message"`
	Policy  map[string]interface{} `json:"policy"`
}

// SelfStorageLocationPrefix defines model for SelfStorageLocationPrefix.
type SelfStorageLocationPrefix struct {
	Message string `json:"message"`
	Prefix  string `json:"prefix"`
}

// SelfStorageLocationServiceAccounts defines model for SelfStorageLocationServiceAccounts.
type SelfStorageLocationServiceAccounts struct {
	ClusterMaster string `json:"clusterMaster"`
	Indexer       string `json:"indexer"`
}

// SelfStorageLocationServiceAccountsResponse defines model for SelfStorageLocationServiceAccountsResponse.
type SelfStorageLocationServiceAccountsResponse struct {
	Message         string                              `json:"message"`
	ServiceAccounts *SelfStorageLocationServiceAccounts `json:"serviceAccounts,omitempty"`
}

// the splunkbase app name and version to install. If no version specified, the latest version will be installed.
type SplunkbaseBody struct {
	SplunkbaseID string  `json:"splunkbaseID"`
	Version      *string `json:"version,omitempty"`
}

// StackStatus defines model for StackStatus.
type StackStatus struct {
	Infrastructure struct {

		// the type of the stack (Victoria/Classic)
		StackType *string `json:"stackType,omitempty"`

		// the version of the stack
		StackVersion *string `json:"stackVersion,omitempty"`

		// the status of the infrastructure 1) Ready - The stack is ready, and infrastructure is up to date. 2) Pending - The stack has some pending changes that haven't been applied to the stack yet. The changes could be internal system changes for stacks or user requested changes like modification to allow lists. 3) Failed - There were some errors while applying changes to the stacks were being applied. The changes could be internal system changes for stacks or user requested changes like modification to allow lists. User should reach out to Splunk support for resolution.
		Status *string `json:"status,omitempty"`
	} `json:"infrastructure"`
	Messages struct {

		// The stack has a notification to restart splunk server. User should restart stack via UI for all configurations to be completed. It may take some time for the correct state for restart-required field to be populated in a Search Head Cluster, given sync delays with different Search Heads
		RestartRequired *bool `json:"restartRequired,omitempty"`
	} `json:"messages"`
}

// TokenBody defines model for TokenBody.
type TokenBody struct {
	Audience  string  `json:"audience"`
	ExpiresOn *string `json:"expiresOn,omitempty"`
	Type      *string `json:"type,omitempty"`
	User      string  `json:"user"`
}

// TokenInfo defines model for TokenInfo.
type TokenInfo struct {
	Audience   string     `json:"audience"`
	ExpiresOn  time.Time  `json:"expiresOn"`
	Id         string     `json:"id"`
	LastUsed   *time.Time `json:"lastUsed,omitempty"`
	LastUsedIP *string    `json:"lastUsedIP,omitempty"`
	NotBefore  time.Time  `json:"notBefore"`
	Status     string     `json:"status"`
	Token      *string    `json:"token,omitempty"`
	Type       *string    `json:"type,omitempty"`
	User       string     `json:"user"`
}

// UpdateManagedGlueResources defines model for UpdateManagedGlueResources.
type UpdateManagedGlueResources struct {
	ManagedGlueResources *[]ManagedGlueResources `json:"managedGlueResources,omitempty"`
}

// UpdatePrivateConnectivity defines model for UpdatePrivateConnectivity.
type UpdatePrivateConnectivity struct {
	Feature                   *PrivateConnectivityFeatures `json:"feature,omitempty"`
	PatchedCustomerAccountIds *[]string                    `json:"patchedCustomerAccountIds,omitempty"`
}

// Splunk user
type UsersResponse struct {
	Capabilities        []string `json:"capabilities"`
	DefaultApp          string   `json:"defaultApp"`
	DefaultAppSource    string   `json:"defaultAppSource"`
	Email               string   `json:"email"`
	FullName            string   `json:"fullName"`
	LastSuccessfulLogin *string  `json:"lastSuccessfulLogin,omitempty"`
	LockedOut           bool     `json:"lockedOut"`
	Name                string   `json:"name"`
	Roles               []string `json:"roles"`
}

// WarningResponse defines model for WarningResponse.
type WarningResponse struct {
	Warnings *[]string `json:"warnings,omitempty"`
}

// Extra defines model for extra.
type Extra struct {
	ColumnIndexes  *[]int  `json:"columnIndexes,omitempty"`
	OrgID          *string `json:"orgID,omitempty"`
	PartitionStyle *string `json:"partitionStyle,omitempty"`
}

// PartitionProjection defines model for partitionProjection.
type PartitionProjection struct {
	AccountIDKeyName *string  `json:"accountIDKeyName,omitempty"`
	AccountIDs       []string `json:"accountIDs"`
	RegionKeyName    *string  `json:"regionKeyName,omitempty"`
	Regions          []string `json:"regions"`
	TimeDayKeyName   *string  `json:"timeDayKeyName,omitempty"`
	TimeHourKeyName  *string  `json:"timeHourKeyName,omitempty"`
	TimeKeyName      *string  `json:"timeKeyName,omitempty"`
	TimeMonthKeyName *string  `json:"timeMonthKeyName,omitempty"`
	TimeRange        *string  `json:"timeRange,omitempty"`
	TimeUnit         *string  `json:"timeUnit,omitempty"`
}

// AppName defines model for app-name.
type AppName string

// AppGroup defines model for appGroup.
type AppGroup string

// BucketName defines model for bucketName.
type BucketName string

// BucketPath defines model for bucketPath.
type BucketPath string

// ConfsOnly defines model for confsOnly.
type ConfsOnly bool

// Count defines model for count.
type Count int64

// DefaultDirectory defines model for defaultDirectory.
type DefaultDirectory bool

// DeploymentID defines model for deploymentID.
type DeploymentID string

// Feature defines model for feature.
type Feature string

// List of Feature
const (
	Feature_hec        Feature = "hec"
	Feature_idm_api    Feature = "idm-api"
	Feature_idm_ui     Feature = "idm-ui"
	Feature_s2s        Feature = "s2s"
	Feature_search_api Feature = "search-api"
	Feature_search_ui  Feature = "search-ui"
)

// FeatureName defines model for featureName.
type FeatureName string

// FederatedSearchManage defines model for federatedSearchManage.
type FederatedSearchManage string

// FromTime defines model for fromTime.
type FromTime string

// GrantableOnly defines model for grantableOnly.
type GrantableOnly bool

// Hec defines model for hec.
type Hec string

// Index defines model for index.
type Index string

// Key defines model for key.
type Key string

// LocalDirectory defines model for localDirectory.
type LocalDirectory bool

// NextLink defines model for nextLink.
type NextLink string

// Offset defines model for offset.
type Offset int64

// RoleName defines model for roleName.
type RoleName string

// ScheduleID defines model for scheduleID.
type ScheduleID string

// Stack defines model for stack.
type Stack string

// Stanza defines model for stanza.
type Stanza string

// ToTime defines model for toTime.
type ToTime string

// TokenID defines model for tokenID.
type TokenID string

// TokenStatus defines model for tokenStatus.
type TokenStatus string

// UserName defines model for userName.
type UserName string

// Username defines model for username.
type Username string

// UsersDirectory defines model for usersDirectory.
type UsersDirectory bool

// WorkflowName defines model for workflowName.
type WorkflowName string

// DefaultError defines model for defaultError.
type DefaultError Error

// AddOutboundportsJSONBody defines parameters for AddOutboundports.
type AddOutboundportsJSONBody struct {
	OutboundPorts *[]struct {
		Port    *int32    `json:"port,omitempty"`
		Subnets *[]string `json:"subnets,omitempty"`
	} `json:"outboundPorts,omitempty"`
	Reason *string `json:"reason,omitempty"`
}

// CreateOutboundPortsV6JSONBody defines parameters for CreateOutboundPortsV6.
type CreateOutboundPortsV6JSONBody struct {
	OutboundPorts *[]struct {
		Port    *int32    `json:"port,omitempty"`
		Subnets *[]string `json:"subnets,omitempty"`
	} `json:"outboundPorts,omitempty"`
	Reason *string `json:"reason,omitempty"`
}

// DeleteOutboundPortV6JSONBody defines parameters for DeleteOutboundPortV6.
type DeleteOutboundPortV6JSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// DeleteOutboundportJSONBody defines parameters for DeleteOutboundport.
type DeleteOutboundportJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// DeleteSubnetsJSONBody defines parameters for DeleteSubnets.
type DeleteSubnetsJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// AddSubnetsJSONBody defines parameters for AddSubnets.
type AddSubnetsJSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// DeleteAllowlistsV6JSONBody defines parameters for DeleteAllowlistsV6.
type DeleteAllowlistsV6JSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// CreateAllowlistV6JSONBody defines parameters for CreateAllowlistV6.
type CreateAllowlistV6JSONBody struct {
	Subnets *[]string `json:"subnets,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`

	// filter apps based on splunkbase and non-splunkbase apps
	Splunkbase *bool `json:"splunkbase,omitempty"`
}

// InstallAppParams defines parameters for InstallApp.
type InstallAppParams struct {

	// is the app available in splunkbase
	Splunkbase *bool `json:"splunkbase,omitempty"`

	// ACS-Legal-Ack is required for installing private apps
	ACSLegalAck string `json:"ACS-Legal-Ack"`

	// Splunkbase sessionID
	XSplunkbaseAuthorization *string `json:"X-Splunkbase-Authorization,omitempty"`

	// The app inspect token
	XSplunkAuthorization *string `json:"X-Splunk-Authorization,omitempty"`

	// ACS-Licensing-Ack is required for installing splunkbase apps
	ACSLicensingAck *string `json:"ACS-Licensing-Ack,omitempty"`
}

// ListAppsVictoriaParams defines parameters for ListAppsVictoria.
type ListAppsVictoriaParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`

	// filter apps based on splunkbase and non-splunkbase apps
	Splunkbase *bool `json:"splunkbase,omitempty"`
}

// InstallAppVictoriaParams defines parameters for InstallAppVictoria.
type InstallAppVictoriaParams struct {

	// is the app available in splunkbase
	Splunkbase *bool `json:"splunkbase,omitempty"`

	// Splunkbase sessionID
	XSplunkbaseAuthorization *string `json:"X-Splunkbase-Authorization,omitempty"`

	// The app inspect token
	XSplunkAuthorization *string `json:"X-Splunk-Authorization,omitempty"`

	// ACS-Legal-Ack is required for installing private apps
	ACSLegalAck *string `json:"ACS-Legal-Ack,omitempty"`

	// ACS-Licensing-Ack is required for installing splunkbase apps
	ACSLicensingAck *string `json:"ACS-Licensing-Ack,omitempty"`
}

// DownloadAppExportVictoriaParams defines parameters for DownloadAppExportVictoria.
type DownloadAppExportVictoriaParams struct {

	// export the default configs for the app etc/apps/<app_id>/default/*
	Default *DefaultDirectory `json:"default,omitempty"`

	// export the local configs for the app under etc/apps/<app_id>/local/*
	Local *LocalDirectory `json:"local,omitempty"`

	// export the configs and data under etc/users/*/<app_id>/* for the users on which the requester has access over
	Users *UsersDirectory `json:"users,omitempty"`

	// export only the configs as per request parameters and donâ€™t export any app data
	ConfsOnly *ConfsOnly `json:"confs_only,omitempty"`
}

// PatchAppVictoriaParams defines parameters for PatchAppVictoria.
type PatchAppVictoriaParams struct {

	// The splunkbase sessionID
	XSplunkbaseAuthorization string `json:"X-Splunkbase-Authorization"`

	// ACS-Licensing-Ack is required for updating splunkbase apps
	ACSLicensingAck string `json:"ACS-Licensing-Ack"`
}

// PatchAppClassicParams defines parameters for PatchAppClassic.
type PatchAppClassicParams struct {

	// The splunkbase sessionID
	XSplunkbaseAuthorization string `json:"X-Splunkbase-Authorization"`

	// ACS-Licensing-Ack is required for updating splunkbase apps
	ACSLicensingAck string `json:"ACS-Licensing-Ack"`
}

// ListCapabilitiesParams defines parameters for ListCapabilities.
type ListCapabilitiesParams struct {

	// only show grantable capabilities
	GrantableOnly *GrantableOnly `json:"grantableOnly,omitempty"`
}

// UpdateManagedGlueResourcesJSONBody defines parameters for UpdateManagedGlueResources.
type UpdateManagedGlueResourcesJSONBody UpdateManagedGlueResources

// ListSelfStorageLocationsParams defines parameters for ListSelfStorageLocations.
type ListSelfStorageLocationsParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// CreateSelfStorageLocationJSONBody defines parameters for CreateSelfStorageLocation.
type CreateSelfStorageLocationJSONBody SelfStorageLocationBody

// PutEmekKeyJSONBody defines parameters for PutEmekKey.
type PutEmekKeyJSONBody struct {
	KeyARN string `json:"keyARN"`
}

// GetEmekPolicyParams defines parameters for GetEmekPolicy.
type GetEmekPolicyParams struct {

	// EMEK-Legal-Ack is required for generating key policy
	EMEKLegalAck string `json:"EMEK-Legal-Ack"`
}

// SetAppFeatureEnablementJSONBody defines parameters for SetAppFeatureEnablement.
type SetAppFeatureEnablementJSONBody AppFeatureEnablement

// ListIndexesParams defines parameters for ListIndexes.
type ListIndexesParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// CreateIndexJSONBody defines parameters for CreateIndex.
type CreateIndexJSONBody IndexInfo

// DeleteIndexJSONBody defines parameters for DeleteIndex.
type DeleteIndexJSONBody map[string]interface{}

// PatchIndexInfoJSONBody defines parameters for PatchIndexInfo.
type PatchIndexInfoJSONBody PatchIndexInfo

// ListHECsParams defines parameters for ListHECs.
type ListHECsParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// CreateHECJSONBody defines parameters for CreateHEC.
type CreateHECJSONBody HecSpec

// DeleteHecJSONBody defines parameters for DeleteHec.
type DeleteHecJSONBody map[string]interface{}

// PatchHECJSONBody defines parameters for PatchHEC.
type PatchHECJSONBody HecSpec

// UpdateHECJSONBody defines parameters for UpdateHEC.
type UpdateHECJSONBody HecSpec

// AddLimitConfigJSONBody defines parameters for AddLimitConfig.
type AddLimitConfigJSONBody LimitConfigurationInfo

// ResetLimitConfigJSONBody defines parameters for ResetLimitConfig.
type ResetLimitConfigJSONBody LimitResetSettingsList

// UpdateMaintenanceWindowsPreferencesJSONBody defines parameters for UpdateMaintenanceWindowsPreferences.
type UpdateMaintenanceWindowsPreferencesJSONBody MaintenanceWindowsPreferencesRequest

// ListMaintenanceWindowsSchedulesParams defines parameters for ListMaintenanceWindowsSchedules.
type ListMaintenanceWindowsSchedulesParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The key for the next page of the result set. A nextLink with the value null indicates there are no more pages.
	NextLink *NextLink `json:"nextLink,omitempty"`

	// The earliest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	FromTime *FromTime `json:"fromTime,omitempty"`

	// The latest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	ToTime *ToTime `json:"toTime,omitempty"`
}

// AuditMaintenanceWindowsScheduleParams defines parameters for AuditMaintenanceWindowsSchedule.
type AuditMaintenanceWindowsScheduleParams struct {

	// The earliest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	FromTime *FromTime `json:"fromTime,omitempty"`

	// The latest time to return results from. Format is expected to be YYYY-MM-DD or in RFC3339. UTC is the default timezone.
	ToTime *ToTime `json:"toTime,omitempty"`
}

// EnableRbacOnO11yParams defines parameters for EnableRbacOnO11y.
type EnableRbacOnO11yParams struct {

	// Observability Admin Access Token
	O11yAccessToken string `json:"o11y-access-token"`
}

// PostObservabilityPairingParams defines parameters for PostObservabilityPairing.
type PostObservabilityPairingParams struct {

	// Observability Admin Access Token
	O11yAccessToken string `json:"o11y-access-token"`
}

// GetObservabilityPairingStatusParams defines parameters for GetObservabilityPairingStatus.
type GetObservabilityPairingStatusParams struct {

	// Observability Admin Access Token
	O11yAccessToken string `json:"o11y-access-token"`
}

// ListPermissionsAppsParams defines parameters for ListPermissionsApps.
type ListPermissionsAppsParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// PatchPermissionsAppsJSONBody defines parameters for PatchPermissionsApps.
type PatchPermissionsAppsJSONBody PatchAppPermsRequest

// DescribePrivateConnectivityParams defines parameters for DescribePrivateConnectivity.
type DescribePrivateConnectivityParams struct {

	// select which feature endpoint tried to retrieve, supported feature: search, ingest. show all if no feature specified
	Feature *string `json:"feature,omitempty"`
}

// UpdatePrivateConnectivityJSONBody defines parameters for UpdatePrivateConnectivity.
type UpdatePrivateConnectivityJSONBody EnablePrivateConnectivity

// EnablePrivateConnectivityJSONBody defines parameters for EnablePrivateConnectivity.
type EnablePrivateConnectivityJSONBody EnablePrivateConnectivity

// ChangePythonVersionJSONBody defines parameters for ChangePythonVersion.
type ChangePythonVersionJSONBody ChangePythonVersionRequest

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody PostRolesRequest

// CreateRoleParams defines parameters for CreateRole.
type CreateRoleParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// PatchRoleInfoJSONBody defines parameters for PatchRoleInfo.
type PatchRoleInfoJSONBody RolesRequest

// PatchRoleInfoParams defines parameters for PatchRoleInfo.
type PatchRoleInfoParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`

	// status of tokens wanted
	Status *TokenStatus `json:"status,omitempty"`

	// user of tokens wanted
	Username *Username `json:"username,omitempty"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody TokenBody

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// The maximum number of results to return.
	Count *Count `json:"count,omitempty"`

	// The offset to start returning items from.
	Offset *Offset `json:"offset,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody CreateUserRequest

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// PatchUserJSONBody defines parameters for PatchUser.
type PatchUserJSONBody PatchUserRequest

// PatchUserParams defines parameters for PatchUser.
type PatchUserParams struct {

	// Set Federated-Search-Manage-Ack to 'Y' to acknowledge your acceptance that roles with fsh_manage capability can send search results data outside the compliant environment
	FederatedSearchManageAck *FederatedSearchManage `json:"Federated-Search-Manage-Ack,omitempty"`
}

// AddOutboundportsJSONRequestBody defines body for AddOutboundports for application/json ContentType.
type AddOutboundportsJSONRequestBody AddOutboundportsJSONBody

// CreateOutboundPortsV6JSONRequestBody defines body for CreateOutboundPortsV6 for application/json ContentType.
type CreateOutboundPortsV6JSONRequestBody CreateOutboundPortsV6JSONBody

// DeleteOutboundPortV6JSONRequestBody defines body for DeleteOutboundPortV6 for application/json ContentType.
type DeleteOutboundPortV6JSONRequestBody DeleteOutboundPortV6JSONBody

// DeleteOutboundportJSONRequestBody defines body for DeleteOutboundport for application/json ContentType.
type DeleteOutboundportJSONRequestBody DeleteOutboundportJSONBody

// DeleteSubnetsJSONRequestBody defines body for DeleteSubnets for application/json ContentType.
type DeleteSubnetsJSONRequestBody DeleteSubnetsJSONBody

// AddSubnetsJSONRequestBody defines body for AddSubnets for application/json ContentType.
type AddSubnetsJSONRequestBody AddSubnetsJSONBody

// DeleteAllowlistsV6JSONRequestBody defines body for DeleteAllowlistsV6 for application/json ContentType.
type DeleteAllowlistsV6JSONRequestBody DeleteAllowlistsV6JSONBody

// CreateAllowlistV6JSONRequestBody defines body for CreateAllowlistV6 for application/json ContentType.
type CreateAllowlistV6JSONRequestBody CreateAllowlistV6JSONBody

// UpdateManagedGlueResourcesJSONRequestBody defines body for UpdateManagedGlueResources for application/json ContentType.
type UpdateManagedGlueResourcesJSONRequestBody UpdateManagedGlueResourcesJSONBody

// CreateSelfStorageLocationJSONRequestBody defines body for CreateSelfStorageLocation for application/json ContentType.
type CreateSelfStorageLocationJSONRequestBody CreateSelfStorageLocationJSONBody

// PutEmekKeyJSONRequestBody defines body for PutEmekKey for application/json ContentType.
type PutEmekKeyJSONRequestBody PutEmekKeyJSONBody

// SetAppFeatureEnablementJSONRequestBody defines body for SetAppFeatureEnablement for application/json ContentType.
type SetAppFeatureEnablementJSONRequestBody SetAppFeatureEnablementJSONBody

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody CreateIndexJSONBody

// DeleteIndexJSONRequestBody defines body for DeleteIndex for application/json ContentType.
type DeleteIndexJSONRequestBody DeleteIndexJSONBody

// PatchIndexInfoJSONRequestBody defines body for PatchIndexInfo for application/json ContentType.
type PatchIndexInfoJSONRequestBody PatchIndexInfoJSONBody

// CreateHECJSONRequestBody defines body for CreateHEC for application/json ContentType.
type CreateHECJSONRequestBody CreateHECJSONBody

// DeleteHecJSONRequestBody defines body for DeleteHec for application/json ContentType.
type DeleteHecJSONRequestBody DeleteHecJSONBody

// PatchHECJSONRequestBody defines body for PatchHEC for application/json ContentType.
type PatchHECJSONRequestBody PatchHECJSONBody

// UpdateHECJSONRequestBody defines body for UpdateHEC for application/json ContentType.
type UpdateHECJSONRequestBody UpdateHECJSONBody

// AddLimitConfigJSONRequestBody defines body for AddLimitConfig for application/json ContentType.
type AddLimitConfigJSONRequestBody AddLimitConfigJSONBody

// ResetLimitConfigJSONRequestBody defines body for ResetLimitConfig for application/json ContentType.
type ResetLimitConfigJSONRequestBody ResetLimitConfigJSONBody

// UpdateMaintenanceWindowsPreferencesJSONRequestBody defines body for UpdateMaintenanceWindowsPreferences for application/json ContentType.
type UpdateMaintenanceWindowsPreferencesJSONRequestBody UpdateMaintenanceWindowsPreferencesJSONBody

// PatchPermissionsAppsJSONRequestBody defines body for PatchPermissionsApps for application/json ContentType.
type PatchPermissionsAppsJSONRequestBody PatchPermissionsAppsJSONBody

// UpdatePrivateConnectivityJSONRequestBody defines body for UpdatePrivateConnectivity for application/json ContentType.
type UpdatePrivateConnectivityJSONRequestBody UpdatePrivateConnectivityJSONBody

// EnablePrivateConnectivityJSONRequestBody defines body for EnablePrivateConnectivity for application/json ContentType.
type EnablePrivateConnectivityJSONRequestBody EnablePrivateConnectivityJSONBody

// ChangePythonVersionJSONRequestBody defines body for ChangePythonVersion for application/json ContentType.
type ChangePythonVersionJSONRequestBody ChangePythonVersionJSONBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody CreateRoleJSONBody

// PatchRoleInfoJSONRequestBody defines body for PatchRoleInfo for application/json ContentType.
type PatchRoleInfoJSONRequestBody PatchRoleInfoJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody CreateTokenJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// PatchUserJSONRequestBody defines body for PatchUser for application/json ContentType.
type PatchUserJSONRequestBody PatchUserJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOutboundports request
	GetOutboundports(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOutboundports request  with any body
	AddOutboundportsWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOutboundports(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOutboundPortsV6 request
	ListOutboundPortsV6(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOutboundPortsV6 request  with any body
	CreateOutboundPortsV6WithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOutboundPortsV6(ctx context.Context, stack Stack, body CreateOutboundPortsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutboundPortV6 request  with any body
	DeleteOutboundPortV6WithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteOutboundPortV6(ctx context.Context, stack Stack, port int32, body DeleteOutboundPortV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeOutboundportsV6 request
	DescribeOutboundportsV6(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutboundport request  with any body
	DeleteOutboundportWithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteOutboundport(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeOutboundports request
	DescribeOutboundports(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnets request  with any body
	DeleteSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSubnets(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAllowlist request
	DescribeAllowlist(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSubnets request  with any body
	AddSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSubnets(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllowlistsV6 request  with any body
	DeleteAllowlistsV6WithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAllowlistsV6(ctx context.Context, stack Stack, feature Feature, body DeleteAllowlistsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAllowlistV6 request
	DescribeAllowlistV6(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAllowlistV6 request  with any body
	CreateAllowlistV6WithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAllowlistV6(ctx context.Context, stack Stack, feature Feature, body CreateAllowlistV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllowlistV6 request
	DeleteAllowlistV6(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallApp request  with any body
	InstallAppWithBody(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppsVictoria request
	ListAppsVictoria(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAppVictoria request  with any body
	InstallAppVictoriaWithBody(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAppExportVictoria request
	DownloadAppExportVictoria(ctx context.Context, stack Stack, app AppName, params *DownloadAppExportVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallAppVictoria request
	UninstallAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAppVictoria request
	DescribeAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppVictoria request  with any body
	PatchAppVictoriaWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallApp request
	UninstallApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeApp request
	DescribeApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppClassic request  with any body
	PatchAppClassicWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCapabilities request
	ListCapabilities(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeManagedGlueResources request
	DescribeManagedGlueResources(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateManagedGlueResources request  with any body
	UpdateManagedGlueResourcesWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateManagedGlueResources(ctx context.Context, stack Stack, body UpdateManagedGlueResourcesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSelfStorageLocations request
	ListSelfStorageLocations(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSelfStorageLocation request  with any body
	CreateSelfStorageLocationWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSelfStorageLocation(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationPolicy request
	GetSelfStorageLocationPolicy(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeSelfStorageLocation request
	DescribeSelfStorageLocation(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationPrefix request
	GetSelfStorageLocationPrefix(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelfStorageLocationServiceAccounts request
	GetSelfStorageLocationServiceAccounts(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetryDeployment request
	RetryDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployment request
	ListDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeDeployment request
	DescribeDeployment(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutEmekKey request  with any body
	PutEmekKeyWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutEmekKey(ctx context.Context, stack Stack, body PutEmekKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmekPolicy request
	GetEmekPolicy(ctx context.Context, stack Stack, params *GetEmekPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeEmekWaiver request
	DescribeEmekWaiver(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeAppFeatureEnablement request
	DescribeAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppFeatureEnablement request  with any body
	SetAppFeatureEnablementWithBody(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexes request
	ListIndexes(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndex request  with any body
	CreateIndexWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request  with any body
	DeleteIndexWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIndex(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexInfo request
	GetIndexInfo(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchIndexInfo request  with any body
	PatchIndexInfoWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchIndexInfo(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHECs request
	ListHECs(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHEC request  with any body
	CreateHECWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHEC(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHec request  with any body
	DeleteHecWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteHec(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeHec request
	DescribeHec(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchHEC request  with any body
	PatchHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchHEC(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHEC request  with any body
	UpdateHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateHEC(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLimitsConfig request
	GetAllLimitsConfig(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLimitsConfigDefaults request
	GetAllLimitsConfigDefaults(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimitConfig request
	GetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddLimitConfig request  with any body
	AddLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimitsConfigDefaults request
	GetLimitsConfigDefaults(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetLimitConfig request  with any body
	ResetLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyLimitConfig request
	GetKeyLimitConfig(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeMaintenanceWindowsPreferences request
	DescribeMaintenanceWindowsPreferences(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMaintenanceWindowsPreferences request  with any body
	UpdateMaintenanceWindowsPreferencesWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMaintenanceWindowsPreferences(ctx context.Context, stack Stack, body UpdateMaintenanceWindowsPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMaintenanceWindowsSchedules request
	ListMaintenanceWindowsSchedules(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeMaintenanceWindowsSchedule request
	DescribeMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditMaintenanceWindowsSchedule request
	AuditMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostObservabilityCapabilitiesOnSplunk request
	PostObservabilityCapabilitiesOnSplunk(ctx context.Context, stack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableRbacOnO11y request
	EnableRbacOnO11y(ctx context.Context, stack string, params *EnableRbacOnO11yParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostObservabilityPairing request
	PostObservabilityPairing(ctx context.Context, stack string, params *PostObservabilityPairingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObservabilityPairingStatus request
	GetObservabilityPairingStatus(ctx context.Context, stack string, pairingId string, params *GetObservabilityPairingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsApps request
	ListPermissionsApps(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribePermissionsApps request
	DescribePermissionsApps(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPermissionsApps request  with any body
	PatchPermissionsAppsWithBody(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPermissionsApps(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidatePrivateConnectivity request
	ValidatePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribePrivateConnectivity request
	DescribePrivateConnectivity(ctx context.Context, stack Stack, params *DescribePrivateConnectivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePrivateConnectivity request  with any body
	UpdatePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePrivateConnectivity(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnablePrivateConnectivity request  with any body
	EnablePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnablePrivateConnectivity(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPythonVersion request
	GetPythonVersion(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePythonVersion request  with any body
	ChangePythonVersionWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePythonVersion(ctx context.Context, stack Stack, body ChangePythonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartStack request
	RestartStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartStatus request
	RestartStatus(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRole request  with any body
	CreateRoleWithBody(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeRole request
	DescribeRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRoleInfo request  with any body
	PatchRoleInfoWithBody(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRoleInfo(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeStack request
	DescribeStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request  with any body
	CreateTokenWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTokenInfo request
	GetTokenInfo(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeUser request
	DescribeUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUser request  with any body
	PatchUserWithBody(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUser(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeWorkflow request
	DescribeWorkflow(ctx context.Context, stack Stack, workflowName WorkflowName, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOutboundports(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutboundportsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOutboundportsWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOutboundportsRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOutboundports(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOutboundportsRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOutboundPortsV6(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOutboundPortsV6Request(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutboundPortsV6WithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutboundPortsV6RequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutboundPortsV6(ctx context.Context, stack Stack, body CreateOutboundPortsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutboundPortsV6Request(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundPortV6WithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundPortV6RequestWithBody(c.Server, stack, port, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundPortV6(ctx context.Context, stack Stack, port int32, body DeleteOutboundPortV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundPortV6Request(c.Server, stack, port, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeOutboundportsV6(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeOutboundportsV6Request(c.Server, stack, port)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundportWithBody(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundportRequestWithBody(c.Server, stack, port, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutboundport(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutboundportRequest(c.Server, stack, port, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeOutboundports(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeOutboundportsRequest(c.Server, stack, port)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetsRequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnets(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetsRequest(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAllowlist(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAllowlistRequest(c.Server, stack, feature)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubnetsWithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubnetsRequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubnets(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubnetsRequest(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowlistsV6WithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowlistsV6RequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowlistsV6(ctx context.Context, stack Stack, feature Feature, body DeleteAllowlistsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowlistsV6Request(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAllowlistV6(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAllowlistV6Request(c.Server, stack, feature)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllowlistV6WithBody(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllowlistV6RequestWithBody(c.Server, stack, feature, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAllowlistV6(ctx context.Context, stack Stack, feature Feature, body CreateAllowlistV6JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAllowlistV6Request(c.Server, stack, feature, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllowlistV6(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllowlistV6Request(c.Server, stack, feature, subnet)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, stack, feature, subnet)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAppWithBody(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAppRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppsVictoria(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsVictoriaRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAppVictoriaWithBody(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAppVictoriaRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAppExportVictoria(ctx context.Context, stack Stack, app AppName, params *DownloadAppExportVictoriaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAppExportVictoriaRequest(c.Server, stack, app, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppVictoriaRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAppVictoria(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppVictoriaRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppVictoriaWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppVictoriaRequestWithBody(c.Server, stack, app, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAppRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeApp(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAppClassicWithBody(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppClassicRequestWithBody(c.Server, stack, app, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCapabilities(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCapabilitiesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeManagedGlueResources(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeManagedGlueResourcesRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManagedGlueResourcesWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManagedGlueResourcesRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManagedGlueResources(ctx context.Context, stack Stack, body UpdateManagedGlueResourcesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManagedGlueResourcesRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSelfStorageLocations(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSelfStorageLocationsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfStorageLocationWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfStorageLocationRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSelfStorageLocation(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSelfStorageLocationRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationPolicy(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationPolicyRequest(c.Server, stack, bucketName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeSelfStorageLocation(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeSelfStorageLocationRequest(c.Server, stack, bucketPath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationPrefix(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationPrefixRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelfStorageLocationServiceAccounts(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfStorageLocationServiceAccountsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetryDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetryDeploymentRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployment(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeDeployment(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeDeploymentRequest(c.Server, stack, deploymentID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEmekKeyWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEmekKeyRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEmekKey(ctx context.Context, stack Stack, body PutEmekKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEmekKeyRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmekPolicy(ctx context.Context, stack Stack, params *GetEmekPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmekPolicyRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeEmekWaiver(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeEmekWaiverRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeAppFeatureEnablementRequest(c.Server, stack, appGroup, featureName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppFeatureEnablementWithBody(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppFeatureEnablementRequestWithBody(c.Server, stack, appGroup, featureName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppFeatureEnablement(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppFeatureEnablementRequest(c.Server, stack, appGroup, featureName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexes(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndexWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequestWithBody(c.Server, stack, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, stack, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexInfo(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexInfoRequest(c.Server, stack, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchIndexInfoWithBody(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchIndexInfoRequestWithBody(c.Server, stack, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchIndexInfo(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchIndexInfoRequest(c.Server, stack, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHECs(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHECsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHECWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHECRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHEC(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHECRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHecWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHecRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHec(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHecRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeHec(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeHecRequest(c.Server, stack, hec)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchHECRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchHEC(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchHECRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHECWithBody(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHECRequestWithBody(c.Server, stack, hec, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHEC(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHECRequest(c.Server, stack, hec, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLimitsConfig(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLimitsConfigRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLimitsConfigDefaults(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLimitsConfigDefaultsRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitConfigRequest(c.Server, stack, stanza)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLimitConfigRequestWithBody(c.Server, stack, stanza, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddLimitConfigRequest(c.Server, stack, stanza, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimitsConfigDefaults(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitsConfigDefaultsRequest(c.Server, stack, stanza)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetLimitConfigWithBody(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetLimitConfigRequestWithBody(c.Server, stack, stanza, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetLimitConfig(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetLimitConfigRequest(c.Server, stack, stanza, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyLimitConfig(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyLimitConfigRequest(c.Server, stack, stanza, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeMaintenanceWindowsPreferences(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeMaintenanceWindowsPreferencesRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMaintenanceWindowsPreferencesWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMaintenanceWindowsPreferencesRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMaintenanceWindowsPreferences(ctx context.Context, stack Stack, body UpdateMaintenanceWindowsPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMaintenanceWindowsPreferencesRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMaintenanceWindowsSchedules(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMaintenanceWindowsSchedulesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeMaintenanceWindowsScheduleRequest(c.Server, stack, scheduleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditMaintenanceWindowsSchedule(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditMaintenanceWindowsScheduleRequest(c.Server, stack, scheduleID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostObservabilityCapabilitiesOnSplunk(ctx context.Context, stack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostObservabilityCapabilitiesOnSplunkRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableRbacOnO11y(ctx context.Context, stack string, params *EnableRbacOnO11yParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableRbacOnO11yRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostObservabilityPairing(ctx context.Context, stack string, params *PostObservabilityPairingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostObservabilityPairingRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObservabilityPairingStatus(ctx context.Context, stack string, pairingId string, params *GetObservabilityPairingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObservabilityPairingStatusRequest(c.Server, stack, pairingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsApps(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsAppsRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribePermissionsApps(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribePermissionsAppsRequest(c.Server, stack, app)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPermissionsAppsWithBody(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPermissionsAppsRequestWithBody(c.Server, stack, app, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPermissionsApps(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPermissionsAppsRequest(c.Server, stack, app, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePrivateConnectivity(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePrivateConnectivityRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribePrivateConnectivity(ctx context.Context, stack Stack, params *DescribePrivateConnectivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribePrivateConnectivityRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateConnectivityRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePrivateConnectivity(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePrivateConnectivityRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePrivateConnectivityWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePrivateConnectivityRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePrivateConnectivity(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePrivateConnectivityRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPythonVersion(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPythonVersionRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePythonVersionWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePythonVersionRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePythonVersion(ctx context.Context, stack Stack, body ChangePythonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePythonVersionRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartStackRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartStatus(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartStatusRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, stack, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, stack, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeRole(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeRoleRequest(c.Server, stack, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoleInfoWithBody(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleInfoRequestWithBody(c.Server, stack, roleName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoleInfo(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoleInfoRequest(c.Server, stack, roleName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeStack(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeStackRequest(c.Server, stack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, stack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, stack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, stack, tokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTokenInfo(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTokenInfoRequest(c.Server, stack, tokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, stack, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, stack, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, stack, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, stack, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeUser(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeUserRequest(c.Server, stack, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserWithBody(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequestWithBody(c.Server, stack, userName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUser(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserRequest(c.Server, stack, userName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeWorkflow(ctx context.Context, stack Stack, workflowName WorkflowName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeWorkflowRequest(c.Server, stack, workflowName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOutboundportsRequest generates requests for GetOutboundports
func NewGetOutboundportsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOutboundportsRequest calls the generic AddOutboundports builder with application/json body
func NewAddOutboundportsRequest(server string, stack Stack, body AddOutboundportsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOutboundportsRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewAddOutboundportsRequestWithBody generates requests for AddOutboundports with any type of body
func NewAddOutboundportsRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOutboundPortsV6Request generates requests for ListOutboundPortsV6
func NewListOutboundPortsV6Request(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports-v6", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOutboundPortsV6Request calls the generic CreateOutboundPortsV6 builder with application/json body
func NewCreateOutboundPortsV6Request(server string, stack Stack, body CreateOutboundPortsV6JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOutboundPortsV6RequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateOutboundPortsV6RequestWithBody generates requests for CreateOutboundPortsV6 with any type of body
func NewCreateOutboundPortsV6RequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports-v6", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutboundPortV6Request calls the generic DeleteOutboundPortV6 builder with application/json body
func NewDeleteOutboundPortV6Request(server string, stack Stack, port int32, body DeleteOutboundPortV6JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteOutboundPortV6RequestWithBody(server, stack, port, "application/json", bodyReader)
}

// NewDeleteOutboundPortV6RequestWithBody generates requests for DeleteOutboundPortV6 with any type of body
func NewDeleteOutboundPortV6RequestWithBody(server string, stack Stack, port int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports-v6/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeOutboundportsV6Request generates requests for DescribeOutboundportsV6
func NewDescribeOutboundportsV6Request(server string, stack Stack, port int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports-v6/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOutboundportRequest calls the generic DeleteOutboundport builder with application/json body
func NewDeleteOutboundportRequest(server string, stack Stack, port int32, body DeleteOutboundportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteOutboundportRequestWithBody(server, stack, port, "application/json", bodyReader)
}

// NewDeleteOutboundportRequestWithBody generates requests for DeleteOutboundport with any type of body
func NewDeleteOutboundportRequestWithBody(server string, stack Stack, port int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeOutboundportsRequest generates requests for DescribeOutboundports
func NewDescribeOutboundportsRequest(server string, stack Stack, port int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/outbound-ports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSubnetsRequest calls the generic DeleteSubnets builder with application/json body
func NewDeleteSubnetsRequest(server string, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSubnetsRequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewDeleteSubnetsRequestWithBody generates requests for DeleteSubnets with any type of body
func NewDeleteSubnetsRequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeAllowlistRequest generates requests for DescribeAllowlist
func NewDescribeAllowlistRequest(server string, stack Stack, feature Feature) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSubnetsRequest calls the generic AddSubnets builder with application/json body
func NewAddSubnetsRequest(server string, stack Stack, feature Feature, body AddSubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSubnetsRequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewAddSubnetsRequestWithBody generates requests for AddSubnets with any type of body
func NewAddSubnetsRequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllowlistsV6Request calls the generic DeleteAllowlistsV6 builder with application/json body
func NewDeleteAllowlistsV6Request(server string, stack Stack, feature Feature, body DeleteAllowlistsV6JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAllowlistsV6RequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewDeleteAllowlistsV6RequestWithBody generates requests for DeleteAllowlistsV6 with any type of body
func NewDeleteAllowlistsV6RequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists-v6", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeAllowlistV6Request generates requests for DescribeAllowlistV6
func NewDescribeAllowlistV6Request(server string, stack Stack, feature Feature) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists-v6", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAllowlistV6Request calls the generic CreateAllowlistV6 builder with application/json body
func NewCreateAllowlistV6Request(server string, stack Stack, feature Feature, body CreateAllowlistV6JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAllowlistV6RequestWithBody(server, stack, feature, "application/json", bodyReader)
}

// NewCreateAllowlistV6RequestWithBody generates requests for CreateAllowlistV6 with any type of body
func NewCreateAllowlistV6RequestWithBody(server string, stack Stack, feature Feature, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists-v6", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllowlistV6Request generates requests for DeleteAllowlistV6
func NewDeleteAllowlistV6Request(server string, stack Stack, feature Feature, subnet string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subnet", runtime.ParamLocationPath, subnet)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists-v6/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, stack Stack, feature Feature, subnet string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "feature", runtime.ParamLocationPath, feature)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subnet", runtime.ParamLocationPath, subnet)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/access/%s/ipallowlists/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, stack Stack, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallAppRequestWithBody generates requests for InstallApp with any type of body
func NewInstallAppRequestWithBody(server string, stack Stack, params *InstallAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "ACS-Legal-Ack", runtime.ParamLocationHeader, params.ACSLegalAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Legal-Ack", headerParam0)

	if params.XSplunkbaseAuthorization != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, *params.XSplunkbaseAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunkbase-Authorization", headerParam1)
	}

	if params.XSplunkAuthorization != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Splunk-Authorization", runtime.ParamLocationHeader, *params.XSplunkAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunk-Authorization", headerParam2)
	}

	if params.ACSLicensingAck != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, *params.ACSLicensingAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Licensing-Ack", headerParam3)
	}

	return req, nil
}

// NewListAppsVictoriaRequest generates requests for ListAppsVictoria
func NewListAppsVictoriaRequest(server string, stack Stack, params *ListAppsVictoriaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallAppVictoriaRequestWithBody generates requests for InstallAppVictoria with any type of body
func NewInstallAppVictoriaRequestWithBody(server string, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Splunkbase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splunkbase", runtime.ParamLocationQuery, *params.Splunkbase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XSplunkbaseAuthorization != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, *params.XSplunkbaseAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunkbase-Authorization", headerParam0)
	}

	if params.XSplunkAuthorization != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Splunk-Authorization", runtime.ParamLocationHeader, *params.XSplunkAuthorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Splunk-Authorization", headerParam1)
	}

	if params.ACSLegalAck != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "ACS-Legal-Ack", runtime.ParamLocationHeader, *params.ACSLegalAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Legal-Ack", headerParam2)
	}

	if params.ACSLicensingAck != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, *params.ACSLicensingAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("ACS-Licensing-Ack", headerParam3)
	}

	return req, nil
}

// NewDownloadAppExportVictoriaRequest generates requests for DownloadAppExportVictoria
func NewDownloadAppExportVictoriaRequest(server string, stack Stack, app AppName, params *DownloadAppExportVictoriaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/export/download/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Default != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Local != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local", runtime.ParamLocationQuery, *params.Local); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Users != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ConfsOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "confs_only", runtime.ParamLocationQuery, *params.ConfsOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallAppVictoriaRequest generates requests for UninstallAppVictoria
func NewUninstallAppVictoriaRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppVictoriaRequest generates requests for DescribeAppVictoria
func NewDescribeAppVictoriaRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppVictoriaRequestWithBody generates requests for PatchAppVictoria with any type of body
func NewPatchAppVictoriaRequestWithBody(server string, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/victoria/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, params.XSplunkbaseAuthorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-Splunkbase-Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, params.ACSLicensingAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Licensing-Ack", headerParam1)

	return req, nil
}

// NewUninstallAppRequest generates requests for UninstallApp
func NewUninstallAppRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppRequest generates requests for DescribeApp
func NewDescribeAppRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppClassicRequestWithBody generates requests for PatchAppClassic with any type of body
func NewPatchAppClassicRequestWithBody(server string, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Splunkbase-Authorization", runtime.ParamLocationHeader, params.XSplunkbaseAuthorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-Splunkbase-Authorization", headerParam0)

	var headerParam1 string

	headerParam1, err = runtime.StyleParamWithLocation("simple", false, "ACS-Licensing-Ack", runtime.ParamLocationHeader, params.ACSLicensingAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("ACS-Licensing-Ack", headerParam1)

	return req, nil
}

// NewListCapabilitiesRequest generates requests for ListCapabilities
func NewListCapabilitiesRequest(server string, stack Stack, params *ListCapabilitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/capabilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.GrantableOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grantableOnly", runtime.ParamLocationQuery, *params.GrantableOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeManagedGlueResourcesRequest generates requests for DescribeManagedGlueResources
func NewDescribeManagedGlueResourcesRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/managed-glue-resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateManagedGlueResourcesRequest calls the generic UpdateManagedGlueResources builder with application/json body
func NewUpdateManagedGlueResourcesRequest(server string, stack Stack, body UpdateManagedGlueResourcesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManagedGlueResourcesRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewUpdateManagedGlueResourcesRequestWithBody generates requests for UpdateManagedGlueResources with any type of body
func NewUpdateManagedGlueResourcesRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/managed-glue-resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSelfStorageLocationsRequest generates requests for ListSelfStorageLocations
func NewListSelfStorageLocationsRequest(server string, stack Stack, params *ListSelfStorageLocationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSelfStorageLocationRequest calls the generic CreateSelfStorageLocation builder with application/json body
func NewCreateSelfStorageLocationRequest(server string, stack Stack, body CreateSelfStorageLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSelfStorageLocationRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateSelfStorageLocationRequestWithBody generates requests for CreateSelfStorageLocation with any type of body
func NewCreateSelfStorageLocationRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSelfStorageLocationPolicyRequest generates requests for GetSelfStorageLocationPolicy
func NewGetSelfStorageLocationPolicyRequest(server string, stack Stack, bucketName BucketName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucketName", runtime.ParamLocationPath, bucketName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets/%s/policy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeSelfStorageLocationRequest generates requests for DescribeSelfStorageLocation
func NewDescribeSelfStorageLocationRequest(server string, stack Stack, bucketPath BucketPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucketPath", runtime.ParamLocationPath, bucketPath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/buckets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelfStorageLocationPrefixRequest generates requests for GetSelfStorageLocationPrefix
func NewGetSelfStorageLocationPrefixRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/configs/prefix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelfStorageLocationServiceAccountsRequest generates requests for GetSelfStorageLocationServiceAccounts
func NewGetSelfStorageLocationServiceAccountsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/cloud-resources/self-storage-locations/configs/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetryDeploymentRequest generates requests for RetryDeployment
func NewRetryDeploymentRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/retry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentRequest generates requests for ListDeployment
func NewListDeploymentRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeDeploymentRequest generates requests for DescribeDeployment
func NewDescribeDeploymentRequest(server string, stack Stack, deploymentID DeploymentID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "deploymentID", runtime.ParamLocationPath, deploymentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/deployment/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutEmekKeyRequest calls the generic PutEmekKey builder with application/json body
func NewPutEmekKeyRequest(server string, stack Stack, body PutEmekKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutEmekKeyRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewPutEmekKeyRequestWithBody generates requests for PutEmekKey with any type of body
func NewPutEmekKeyRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/emek/key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEmekPolicyRequest generates requests for GetEmekPolicy
func NewGetEmekPolicyRequest(server string, stack Stack, params *GetEmekPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/emek/key-policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "EMEK-Legal-Ack", runtime.ParamLocationHeader, params.EMEKLegalAck)
	if err != nil {
		return nil, err
	}

	req.Header.Set("EMEK-Legal-Ack", headerParam0)

	return req, nil
}

// NewDescribeEmekWaiverRequest generates requests for DescribeEmekWaiver
func NewDescribeEmekWaiverRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/emek/waiver", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeAppFeatureEnablementRequest generates requests for DescribeAppFeatureEnablement
func NewDescribeAppFeatureEnablementRequest(server string, stack Stack, appGroup AppGroup, featureName FeatureName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appGroup", runtime.ParamLocationPath, appGroup)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/enablement/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAppFeatureEnablementRequest calls the generic SetAppFeatureEnablement builder with application/json body
func NewSetAppFeatureEnablementRequest(server string, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppFeatureEnablementRequestWithBody(server, stack, appGroup, featureName, "application/json", bodyReader)
}

// NewSetAppFeatureEnablementRequestWithBody generates requests for SetAppFeatureEnablement with any type of body
func NewSetAppFeatureEnablementRequestWithBody(server string, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "appGroup", runtime.ParamLocationPath, appGroup)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "featureName", runtime.ParamLocationPath, featureName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/enablement/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIndexesRequest generates requests for ListIndexes
func NewListIndexesRequest(server string, stack Stack, params *ListIndexesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, stack Stack, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIndexRequest calls the generic DeleteIndex builder with application/json body
func NewDeleteIndexRequest(server string, stack Stack, index Index, body DeleteIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIndexRequestWithBody(server, stack, index, "application/json", bodyReader)
}

// NewDeleteIndexRequestWithBody generates requests for DeleteIndex with any type of body
func NewDeleteIndexRequestWithBody(server string, stack Stack, index Index, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIndexInfoRequest generates requests for GetIndexInfo
func NewGetIndexInfoRequest(server string, stack Stack, index Index) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchIndexInfoRequest calls the generic PatchIndexInfo builder with application/json body
func NewPatchIndexInfoRequest(server string, stack Stack, index Index, body PatchIndexInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchIndexInfoRequestWithBody(server, stack, index, "application/json", bodyReader)
}

// NewPatchIndexInfoRequestWithBody generates requests for PatchIndexInfo with any type of body
func NewPatchIndexInfoRequestWithBody(server string, stack Stack, index Index, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListHECsRequest generates requests for ListHECs
func NewListHECsRequest(server string, stack Stack, params *ListHECsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHECRequest calls the generic CreateHEC builder with application/json body
func NewCreateHECRequest(server string, stack Stack, body CreateHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHECRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateHECRequestWithBody generates requests for CreateHEC with any type of body
func NewCreateHECRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHecRequest calls the generic DeleteHec builder with application/json body
func NewDeleteHecRequest(server string, stack Stack, hec Hec, body DeleteHecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteHecRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewDeleteHecRequestWithBody generates requests for DeleteHec with any type of body
func NewDeleteHecRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDescribeHecRequest generates requests for DescribeHec
func NewDescribeHecRequest(server string, stack Stack, hec Hec) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchHECRequest calls the generic PatchHEC builder with application/json body
func NewPatchHECRequest(server string, stack Stack, hec Hec, body PatchHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchHECRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewPatchHECRequestWithBody generates requests for PatchHEC with any type of body
func NewPatchHECRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateHECRequest calls the generic UpdateHEC builder with application/json body
func NewUpdateHECRequest(server string, stack Stack, hec Hec, body UpdateHECJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateHECRequestWithBody(server, stack, hec, "application/json", bodyReader)
}

// NewUpdateHECRequestWithBody generates requests for UpdateHEC with any type of body
func NewUpdateHECRequestWithBody(server string, stack Stack, hec Hec, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hec", runtime.ParamLocationPath, hec)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/inputs/http-event-collectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLimitsConfigRequest generates requests for GetAllLimitsConfig
func NewGetAllLimitsConfigRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllLimitsConfigDefaultsRequest generates requests for GetAllLimitsConfigDefaults
func NewGetAllLimitsConfigDefaultsRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/defaults", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLimitConfigRequest generates requests for GetLimitConfig
func NewGetLimitConfigRequest(server string, stack Stack, stanza Stanza) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddLimitConfigRequest calls the generic AddLimitConfig builder with application/json body
func NewAddLimitConfigRequest(server string, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddLimitConfigRequestWithBody(server, stack, stanza, "application/json", bodyReader)
}

// NewAddLimitConfigRequestWithBody generates requests for AddLimitConfig with any type of body
func NewAddLimitConfigRequestWithBody(server string, stack Stack, stanza Stanza, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLimitsConfigDefaultsRequest generates requests for GetLimitsConfigDefaults
func NewGetLimitsConfigDefaultsRequest(server string, stack Stack, stanza Stanza) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/defaults", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetLimitConfigRequest calls the generic ResetLimitConfig builder with application/json body
func NewResetLimitConfigRequest(server string, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetLimitConfigRequestWithBody(server, stack, stanza, "application/json", bodyReader)
}

// NewResetLimitConfigRequestWithBody generates requests for ResetLimitConfig with any type of body
func NewResetLimitConfigRequestWithBody(server string, stack Stack, stanza Stanza, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeyLimitConfigRequest generates requests for GetKeyLimitConfig
func NewGetKeyLimitConfigRequest(server string, stack Stack, stanza Stanza, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stanza", runtime.ParamLocationPath, stanza)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/limits/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeMaintenanceWindowsPreferencesRequest generates requests for DescribeMaintenanceWindowsPreferences
func NewDescribeMaintenanceWindowsPreferencesRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/preferences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMaintenanceWindowsPreferencesRequest calls the generic UpdateMaintenanceWindowsPreferences builder with application/json body
func NewUpdateMaintenanceWindowsPreferencesRequest(server string, stack Stack, body UpdateMaintenanceWindowsPreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMaintenanceWindowsPreferencesRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewUpdateMaintenanceWindowsPreferencesRequestWithBody generates requests for UpdateMaintenanceWindowsPreferences with any type of body
func NewUpdateMaintenanceWindowsPreferencesRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/preferences", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMaintenanceWindowsSchedulesRequest generates requests for ListMaintenanceWindowsSchedules
func NewListMaintenanceWindowsSchedulesRequest(server string, stack Stack, params *ListMaintenanceWindowsSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextLink != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextLink", runtime.ParamLocationQuery, *params.NextLink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FromTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTime", runtime.ParamLocationQuery, *params.FromTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTime", runtime.ParamLocationQuery, *params.ToTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeMaintenanceWindowsScheduleRequest generates requests for DescribeMaintenanceWindowsSchedule
func NewDescribeMaintenanceWindowsScheduleRequest(server string, stack Stack, scheduleID ScheduleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduleID", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuditMaintenanceWindowsScheduleRequest generates requests for AuditMaintenanceWindowsSchedule
func NewAuditMaintenanceWindowsScheduleRequest(server string, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduleID", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/maintenance-windows/schedules/%s/audits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.FromTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromTime", runtime.ParamLocationQuery, *params.FromTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toTime", runtime.ParamLocationQuery, *params.ToTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostObservabilityCapabilitiesOnSplunkRequest generates requests for PostObservabilityCapabilitiesOnSplunk
func NewPostObservabilityCapabilitiesOnSplunkRequest(server string, stack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/observability/capabilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableRbacOnO11yRequest generates requests for EnableRbacOnO11y
func NewEnableRbacOnO11yRequest(server string, stack string, params *EnableRbacOnO11yParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/observability/enable-centralized-rbac", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "o11y-access-token", runtime.ParamLocationHeader, params.O11yAccessToken)
	if err != nil {
		return nil, err
	}

	req.Header.Set("o11y-access-token", headerParam0)

	return req, nil
}

// NewPostObservabilityPairingRequest generates requests for PostObservabilityPairing
func NewPostObservabilityPairingRequest(server string, stack string, params *PostObservabilityPairingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/observability/sso-pairing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "o11y-access-token", runtime.ParamLocationHeader, params.O11yAccessToken)
	if err != nil {
		return nil, err
	}

	req.Header.Set("o11y-access-token", headerParam0)

	return req, nil
}

// NewGetObservabilityPairingStatusRequest generates requests for GetObservabilityPairingStatus
func NewGetObservabilityPairingStatusRequest(server string, stack string, pairingId string, params *GetObservabilityPairingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pairingId", runtime.ParamLocationPath, pairingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/observability/sso-pairing/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "o11y-access-token", runtime.ParamLocationHeader, params.O11yAccessToken)
	if err != nil {
		return nil, err
	}

	req.Header.Set("o11y-access-token", headerParam0)

	return req, nil
}

// NewListPermissionsAppsRequest generates requests for ListPermissionsApps
func NewListPermissionsAppsRequest(server string, stack Stack, params *ListPermissionsAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribePermissionsAppsRequest generates requests for DescribePermissionsApps
func NewDescribePermissionsAppsRequest(server string, stack Stack, app AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPermissionsAppsRequest calls the generic PatchPermissionsApps builder with application/json body
func NewPatchPermissionsAppsRequest(server string, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPermissionsAppsRequestWithBody(server, stack, app, "application/json", bodyReader)
}

// NewPatchPermissionsAppsRequestWithBody generates requests for PatchPermissionsApps with any type of body
func NewPatchPermissionsAppsRequestWithBody(server string, stack Stack, app AppName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, app)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/permissions/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidatePrivateConnectivityRequest generates requests for ValidatePrivateConnectivity
func NewValidatePrivateConnectivityRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/eligibility", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribePrivateConnectivityRequest generates requests for DescribePrivateConnectivity
func NewDescribePrivateConnectivityRequest(server string, stack Stack, params *DescribePrivateConnectivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Feature != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature", runtime.ParamLocationQuery, *params.Feature); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePrivateConnectivityRequest calls the generic UpdatePrivateConnectivity builder with application/json body
func NewUpdatePrivateConnectivityRequest(server string, stack Stack, body UpdatePrivateConnectivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePrivateConnectivityRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewUpdatePrivateConnectivityRequestWithBody generates requests for UpdatePrivateConnectivity with any type of body
func NewUpdatePrivateConnectivityRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnablePrivateConnectivityRequest calls the generic EnablePrivateConnectivity builder with application/json body
func NewEnablePrivateConnectivityRequest(server string, stack Stack, body EnablePrivateConnectivityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnablePrivateConnectivityRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewEnablePrivateConnectivityRequestWithBody generates requests for EnablePrivateConnectivity with any type of body
func NewEnablePrivateConnectivityRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/private-connectivity/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPythonVersionRequest generates requests for GetPythonVersion
func NewGetPythonVersionRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/python-runtime", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePythonVersionRequest calls the generic ChangePythonVersion builder with application/json body
func NewChangePythonVersionRequest(server string, stack Stack, body ChangePythonVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePythonVersionRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewChangePythonVersionRequestWithBody generates requests for ChangePythonVersion with any type of body
func NewChangePythonVersionRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/python-runtime", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestartStackRequest generates requests for RestartStack
func NewRestartStackRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/restart-now", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartStatusRequest generates requests for RestartStatus
func NewRestartStatusRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/restart/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, stack Stack, params *ListRolesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, stack, params, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, stack Stack, params *CreateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, stack Stack, roleName RoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeRoleRequest generates requests for DescribeRole
func NewDescribeRoleRequest(server string, stack Stack, roleName RoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRoleInfoRequest calls the generic PatchRoleInfo builder with application/json body
func NewPatchRoleInfoRequest(server string, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRoleInfoRequestWithBody(server, stack, roleName, params, "application/json", bodyReader)
}

// NewPatchRoleInfoRequestWithBody generates requests for PatchRoleInfo with any type of body
func NewPatchRoleInfoRequestWithBody(server string, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleName", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDescribeStackRequest generates requests for DescribeStack
func NewDescribeStackRequest(server string, stack Stack) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string, stack Stack, params *ListTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Username != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, stack Stack, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, stack, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, stack Stack, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, stack Stack, tokenID TokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTokenInfoRequest generates requests for GetTokenInfo
func NewGetTokenInfoRequest(server string, stack Stack, tokenID TokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tokenID", runtime.ParamLocationPath, tokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, stack Stack, params *ListUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, stack, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, stack Stack, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, stack Stack, userName UserName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeUserRequest generates requests for DescribeUser
func NewDescribeUserRequest(server string, stack Stack, userName UserName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserRequest calls the generic PatchUser builder with application/json body
func NewPatchUserRequest(server string, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserRequestWithBody(server, stack, userName, params, "application/json", bodyReader)
}

// NewPatchUserRequestWithBody generates requests for PatchUser with any type of body
func NewPatchUserRequestWithBody(server string, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userName", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.FederatedSearchManageAck != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Federated-Search-Manage-Ack", runtime.ParamLocationHeader, *params.FederatedSearchManageAck)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Federated-Search-Manage-Ack", headerParam0)
	}

	return req, nil
}

// NewDescribeWorkflowRequest generates requests for DescribeWorkflow
func NewDescribeWorkflowRequest(server string, stack Stack, workflowName WorkflowName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stack", runtime.ParamLocationPath, stack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflowName", runtime.ParamLocationPath, workflowName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/adminconfig/v2/workflows/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOutboundports request
	GetOutboundportsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetOutboundportsResponse, error)

	// AddOutboundports request  with any body
	AddOutboundportsWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error)

	AddOutboundportsWithResponse(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error)

	// ListOutboundPortsV6 request
	ListOutboundPortsV6WithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListOutboundPortsV6Response, error)

	// CreateOutboundPortsV6 request  with any body
	CreateOutboundPortsV6WithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutboundPortsV6Response, error)

	CreateOutboundPortsV6WithResponse(ctx context.Context, stack Stack, body CreateOutboundPortsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutboundPortsV6Response, error)

	// DeleteOutboundPortV6 request  with any body
	DeleteOutboundPortV6WithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundPortV6Response, error)

	DeleteOutboundPortV6WithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundPortV6JSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundPortV6Response, error)

	// DescribeOutboundportsV6 request
	DescribeOutboundportsV6WithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsV6Response, error)

	// DeleteOutboundport request  with any body
	DeleteOutboundportWithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error)

	DeleteOutboundportWithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error)

	// DescribeOutboundports request
	DescribeOutboundportsWithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsResponse, error)

	// DeleteSubnets request  with any body
	DeleteSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error)

	DeleteSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error)

	// DescribeAllowlist request
	DescribeAllowlistWithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistResponse, error)

	// AddSubnets request  with any body
	AddSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error)

	AddSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error)

	// DeleteAllowlistsV6 request  with any body
	DeleteAllowlistsV6WithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAllowlistsV6Response, error)

	DeleteAllowlistsV6WithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteAllowlistsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAllowlistsV6Response, error)

	// DescribeAllowlistV6 request
	DescribeAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistV6Response, error)

	// CreateAllowlistV6 request  with any body
	CreateAllowlistV6WithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistV6Response, error)

	CreateAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, body CreateAllowlistV6JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAllowlistV6Response, error)

	// DeleteAllowlistV6 request
	DeleteAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteAllowlistV6Response, error)

	// DeleteSubnet request
	DeleteSubnetWithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ListApps request
	ListAppsWithResponse(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// InstallApp request  with any body
	InstallAppWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppResponse, error)

	// ListAppsVictoria request
	ListAppsVictoriaWithResponse(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*ListAppsVictoriaResponse, error)

	// InstallAppVictoria request  with any body
	InstallAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppVictoriaResponse, error)

	// DownloadAppExportVictoria request
	DownloadAppExportVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, params *DownloadAppExportVictoriaParams, reqEditors ...RequestEditorFn) (*DownloadAppExportVictoriaResponse, error)

	// UninstallAppVictoria request
	UninstallAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppVictoriaResponse, error)

	// DescribeAppVictoria request
	DescribeAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppVictoriaResponse, error)

	// PatchAppVictoria request  with any body
	PatchAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppVictoriaResponse, error)

	// UninstallApp request
	UninstallAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error)

	// DescribeApp request
	DescribeAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppResponse, error)

	// PatchAppClassic request  with any body
	PatchAppClassicWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppClassicResponse, error)

	// ListCapabilities request
	ListCapabilitiesWithResponse(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*ListCapabilitiesResponse, error)

	// DescribeManagedGlueResources request
	DescribeManagedGlueResourcesWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeManagedGlueResourcesResponse, error)

	// UpdateManagedGlueResources request  with any body
	UpdateManagedGlueResourcesWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManagedGlueResourcesResponse, error)

	UpdateManagedGlueResourcesWithResponse(ctx context.Context, stack Stack, body UpdateManagedGlueResourcesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManagedGlueResourcesResponse, error)

	// ListSelfStorageLocations request
	ListSelfStorageLocationsWithResponse(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*ListSelfStorageLocationsResponse, error)

	// CreateSelfStorageLocation request  with any body
	CreateSelfStorageLocationWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error)

	CreateSelfStorageLocationWithResponse(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error)

	// GetSelfStorageLocationPolicy request
	GetSelfStorageLocationPolicyWithResponse(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPolicyResponse, error)

	// DescribeSelfStorageLocation request
	DescribeSelfStorageLocationWithResponse(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*DescribeSelfStorageLocationResponse, error)

	// GetSelfStorageLocationPrefix request
	GetSelfStorageLocationPrefixWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPrefixResponse, error)

	// GetSelfStorageLocationServiceAccounts request
	GetSelfStorageLocationServiceAccountsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationServiceAccountsResponse, error)

	// RetryDeployment request
	RetryDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RetryDeploymentResponse, error)

	// ListDeployment request
	ListDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListDeploymentResponse, error)

	// DescribeDeployment request
	DescribeDeploymentWithResponse(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*DescribeDeploymentResponse, error)

	// PutEmekKey request  with any body
	PutEmekKeyWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEmekKeyResponse, error)

	PutEmekKeyWithResponse(ctx context.Context, stack Stack, body PutEmekKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEmekKeyResponse, error)

	// GetEmekPolicy request
	GetEmekPolicyWithResponse(ctx context.Context, stack Stack, params *GetEmekPolicyParams, reqEditors ...RequestEditorFn) (*GetEmekPolicyResponse, error)

	// DescribeEmekWaiver request
	DescribeEmekWaiverWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeEmekWaiverResponse, error)

	// DescribeAppFeatureEnablement request
	DescribeAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*DescribeAppFeatureEnablementResponse, error)

	// SetAppFeatureEnablement request  with any body
	SetAppFeatureEnablementWithBodyWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error)

	SetAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error)

	// ListIndexes request
	ListIndexesWithResponse(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error)

	// CreateIndex request  with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// DeleteIndex request  with any body
	DeleteIndexWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	DeleteIndexWithResponse(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// GetIndexInfo request
	GetIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*GetIndexInfoResponse, error)

	// PatchIndexInfo request  with any body
	PatchIndexInfoWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error)

	PatchIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error)

	// ListHECs request
	ListHECsWithResponse(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*ListHECsResponse, error)

	// CreateHEC request  with any body
	CreateHECWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHECResponse, error)

	CreateHECWithResponse(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHECResponse, error)

	// DeleteHec request  with any body
	DeleteHecWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error)

	DeleteHecWithResponse(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error)

	// DescribeHec request
	DescribeHecWithResponse(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*DescribeHecResponse, error)

	// PatchHEC request  with any body
	PatchHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchHECResponse, error)

	PatchHECWithResponse(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchHECResponse, error)

	// UpdateHEC request  with any body
	UpdateHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error)

	UpdateHECWithResponse(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error)

	// GetAllLimitsConfig request
	GetAllLimitsConfigWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigResponse, error)

	// GetAllLimitsConfigDefaults request
	GetAllLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigDefaultsResponse, error)

	// GetLimitConfig request
	GetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitConfigResponse, error)

	// AddLimitConfig request  with any body
	AddLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error)

	AddLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error)

	// GetLimitsConfigDefaults request
	GetLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitsConfigDefaultsResponse, error)

	// ResetLimitConfig request  with any body
	ResetLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error)

	ResetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error)

	// GetKeyLimitConfig request
	GetKeyLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*GetKeyLimitConfigResponse, error)

	// DescribeMaintenanceWindowsPreferences request
	DescribeMaintenanceWindowsPreferencesWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsPreferencesResponse, error)

	// UpdateMaintenanceWindowsPreferences request  with any body
	UpdateMaintenanceWindowsPreferencesWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMaintenanceWindowsPreferencesResponse, error)

	UpdateMaintenanceWindowsPreferencesWithResponse(ctx context.Context, stack Stack, body UpdateMaintenanceWindowsPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMaintenanceWindowsPreferencesResponse, error)

	// ListMaintenanceWindowsSchedules request
	ListMaintenanceWindowsSchedulesWithResponse(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*ListMaintenanceWindowsSchedulesResponse, error)

	// DescribeMaintenanceWindowsSchedule request
	DescribeMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsScheduleResponse, error)

	// AuditMaintenanceWindowsSchedule request
	AuditMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*AuditMaintenanceWindowsScheduleResponse, error)

	// PostObservabilityCapabilitiesOnSplunk request
	PostObservabilityCapabilitiesOnSplunkWithResponse(ctx context.Context, stack string, reqEditors ...RequestEditorFn) (*PostObservabilityCapabilitiesOnSplunkResponse, error)

	// EnableRbacOnO11y request
	EnableRbacOnO11yWithResponse(ctx context.Context, stack string, params *EnableRbacOnO11yParams, reqEditors ...RequestEditorFn) (*EnableRbacOnO11yResponse, error)

	// PostObservabilityPairing request
	PostObservabilityPairingWithResponse(ctx context.Context, stack string, params *PostObservabilityPairingParams, reqEditors ...RequestEditorFn) (*PostObservabilityPairingResponse, error)

	// GetObservabilityPairingStatus request
	GetObservabilityPairingStatusWithResponse(ctx context.Context, stack string, pairingId string, params *GetObservabilityPairingStatusParams, reqEditors ...RequestEditorFn) (*GetObservabilityPairingStatusResponse, error)

	// ListPermissionsApps request
	ListPermissionsAppsWithResponse(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*ListPermissionsAppsResponse, error)

	// DescribePermissionsApps request
	DescribePermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribePermissionsAppsResponse, error)

	// PatchPermissionsApps request  with any body
	PatchPermissionsAppsWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error)

	PatchPermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error)

	// ValidatePrivateConnectivity request
	ValidatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ValidatePrivateConnectivityResponse, error)

	// DescribePrivateConnectivity request
	DescribePrivateConnectivityWithResponse(ctx context.Context, stack Stack, params *DescribePrivateConnectivityParams, reqEditors ...RequestEditorFn) (*DescribePrivateConnectivityResponse, error)

	// UpdatePrivateConnectivity request  with any body
	UpdatePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error)

	UpdatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error)

	// EnablePrivateConnectivity request  with any body
	EnablePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error)

	EnablePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error)

	// GetPythonVersion request
	GetPythonVersionWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetPythonVersionResponse, error)

	// ChangePythonVersion request  with any body
	ChangePythonVersionWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePythonVersionResponse, error)

	ChangePythonVersionWithResponse(ctx context.Context, stack Stack, body ChangePythonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePythonVersionResponse, error)

	// RestartStack request
	RestartStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStackResponse, error)

	// RestartStatus request
	RestartStatusWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStatusResponse, error)

	// ListRoles request
	ListRolesWithResponse(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// CreateRole request  with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteRole request
	DeleteRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// DescribeRole request
	DescribeRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DescribeRoleResponse, error)

	// PatchRoleInfo request  with any body
	PatchRoleInfoWithBodyWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error)

	PatchRoleInfoWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error)

	// DescribeStack request
	DescribeStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeStackResponse, error)

	// ListTokens request
	ListTokensWithResponse(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// CreateToken request  with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteToken request
	DeleteTokenWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetTokenInfo request
	GetTokenInfoWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*GetTokenInfoResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// DescribeUser request
	DescribeUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DescribeUserResponse, error)

	// PatchUser request  with any body
	PatchUserWithBodyWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)

	PatchUserWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error)

	// DescribeWorkflow request
	DescribeWorkflowWithResponse(ctx context.Context, stack Stack, workflowName WorkflowName, reqEditors ...RequestEditorFn) (*DescribeWorkflowResponse, error)
}

type GetOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutboundResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOutboundPortsV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutboundResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListOutboundPortsV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOutboundPortsV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOutboundPortsV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateOutboundPortsV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOutboundPortsV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutboundPortV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOutboundPortV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutboundPortV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeOutboundportsV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutboundResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeOutboundportsV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeOutboundportsV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutboundportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOutboundportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutboundportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeOutboundportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OutboundResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeOutboundportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeOutboundportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAllowlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// the subnets from where the stack feature is accessible from
		Subnets *[]string `json:"subnets,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAllowlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAllowlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllowlistsV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAllowlistsV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllowlistsV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAllowlistV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// the ipv6 subnets from where the stack feature is accessible from
		Subnets *[]string `json:"subnets,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAllowlistV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAllowlistV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAllowlistV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateAllowlistV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAllowlistV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllowlistV6Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAllowlistV6Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllowlistV6Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarningResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]App `json:"apps,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]App `json:"apps,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListAppsVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InstallAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAppExportVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DownloadAppExportVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAppExportVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UninstallAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppVictoriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchAppVictoriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppVictoriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UninstallAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppClassicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON202      *App
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchAppClassicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppClassicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapabilitiesInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeManagedGlueResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeManagedGlueResources
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeManagedGlueResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeManagedGlueResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManagedGlueResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateManagedGlueResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManagedGlueResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSelfStorageLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SelfStorageLocations []SelfStorageLocationInfo `json:"selfStorageLocations"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListSelfStorageLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSelfStorageLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSelfStorageLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SelfStorageLocationInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSelfStorageLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSelfStorageLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationPolicy
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeSelfStorageLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeSelfStorageLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeSelfStorageLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationPrefixResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationPrefix
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationPrefixResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationPrefixResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfStorageLocationServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelfStorageLocationServiceAccountsResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSelfStorageLocationServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfStorageLocationServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetryDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentInfo `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RetryDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetryDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentStatus `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *DeploymentInfo `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutEmekKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *EmekKeyUploadResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutEmekKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutEmekKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmekPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmekPolicy
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEmekPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmekPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeEmekWaiverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeEmekWaiverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeEmekWaiverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeAppFeatureEnablementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppFeatureEnablement
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeAppFeatureEnablementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeAppFeatureEnablementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppFeatureEnablementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AppFeatureEnablement
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetAppFeatureEnablementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppFeatureEnablementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Indexes *[]IndexResponse `json:"indexes,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *IndexInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Indexinfo *IndexResponse `json:"indexinfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetIndexInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchIndexInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchIndexInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchIndexInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHECsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		HttpEventCollectors *[]HecInfo `json:"http_event_collectors,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListHECsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHECsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		HttpEventCollector *HecSpec `json:"http-event-collector,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteHecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeHecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		HttpEventCollector *HecInfo `json:"http-event-collector,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeHecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeHecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHECResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateHECResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHECResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLimitsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAllLimitsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLimitsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLimitsConfigDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LimitStanza
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAllLimitsConfigDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLimitsConfigDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsConfigDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LimitStanza
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLimitsConfigDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsConfigDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyLimitConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetKeyLimitConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyLimitConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeMaintenanceWindowsPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceWindowsPreferencesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeMaintenanceWindowsPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeMaintenanceWindowsPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMaintenanceWindowsPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateMaintenanceWindowsPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMaintenanceWindowsPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMaintenanceWindowsSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListMaintenanceWindowsSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMaintenanceWindowsSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeMaintenanceWindowsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceWindowsSchedule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeMaintenanceWindowsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeMaintenanceWindowsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditMaintenanceWindowsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AuditMaintenanceWindowsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditMaintenanceWindowsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostObservabilityCapabilitiesOnSplunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *EnableObservabilityCapabilitiesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostObservabilityCapabilitiesOnSplunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostObservabilityCapabilitiesOnSplunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableRbacOnO11yResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r EnableRbacOnO11yResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableRbacOnO11yResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostObservabilityPairingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateEcSsoPairingResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostObservabilityPairingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostObservabilityPairingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObservabilityPairingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEcSsoPairingStatusResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetObservabilityPairingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObservabilityPairingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *AppPermsList `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribePermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPerms
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribePermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribePermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPermissionsAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchPermissionsAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPermissionsAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidatePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeEligibilityPrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ValidatePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidatePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdatePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnablePrivateConnectivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *EnablePrivateConnectivity
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r EnablePrivateConnectivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnablePrivateConnectivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPythonVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PythonVersionResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPythonVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPythonVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePythonVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PythonVersionResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ChangePythonVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePythonVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RestartResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestartStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ShcStatus *[]RestartStatus `json:"shcStatus,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RestartStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Roles *[]RolesResponse `json:"roles,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRoleInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchRoleInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRoleInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *StackStatus `json:"status,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r DescribeStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokens *[]TokenInfo `json:"tokens,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTokenInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetTokenInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTokenInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Users *[]UsersResponse `json:"users,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DescribeWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOutboundportsWithResponse request returning *GetOutboundportsResponse
func (c *ClientWithResponses) GetOutboundportsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetOutboundportsResponse, error) {
	rsp, err := c.GetOutboundports(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutboundportsResponse(rsp)
}

// AddOutboundportsWithBodyWithResponse request with arbitrary body returning *AddOutboundportsResponse
func (c *ClientWithResponses) AddOutboundportsWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error) {
	rsp, err := c.AddOutboundportsWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOutboundportsResponse(rsp)
}

func (c *ClientWithResponses) AddOutboundportsWithResponse(ctx context.Context, stack Stack, body AddOutboundportsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOutboundportsResponse, error) {
	rsp, err := c.AddOutboundports(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOutboundportsResponse(rsp)
}

// ListOutboundPortsV6WithResponse request returning *ListOutboundPortsV6Response
func (c *ClientWithResponses) ListOutboundPortsV6WithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListOutboundPortsV6Response, error) {
	rsp, err := c.ListOutboundPortsV6(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOutboundPortsV6Response(rsp)
}

// CreateOutboundPortsV6WithBodyWithResponse request with arbitrary body returning *CreateOutboundPortsV6Response
func (c *ClientWithResponses) CreateOutboundPortsV6WithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutboundPortsV6Response, error) {
	rsp, err := c.CreateOutboundPortsV6WithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutboundPortsV6Response(rsp)
}

func (c *ClientWithResponses) CreateOutboundPortsV6WithResponse(ctx context.Context, stack Stack, body CreateOutboundPortsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutboundPortsV6Response, error) {
	rsp, err := c.CreateOutboundPortsV6(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutboundPortsV6Response(rsp)
}

// DeleteOutboundPortV6WithBodyWithResponse request with arbitrary body returning *DeleteOutboundPortV6Response
func (c *ClientWithResponses) DeleteOutboundPortV6WithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundPortV6Response, error) {
	rsp, err := c.DeleteOutboundPortV6WithBody(ctx, stack, port, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundPortV6Response(rsp)
}

func (c *ClientWithResponses) DeleteOutboundPortV6WithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundPortV6JSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundPortV6Response, error) {
	rsp, err := c.DeleteOutboundPortV6(ctx, stack, port, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundPortV6Response(rsp)
}

// DescribeOutboundportsV6WithResponse request returning *DescribeOutboundportsV6Response
func (c *ClientWithResponses) DescribeOutboundportsV6WithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsV6Response, error) {
	rsp, err := c.DescribeOutboundportsV6(ctx, stack, port, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeOutboundportsV6Response(rsp)
}

// DeleteOutboundportWithBodyWithResponse request with arbitrary body returning *DeleteOutboundportResponse
func (c *ClientWithResponses) DeleteOutboundportWithBodyWithResponse(ctx context.Context, stack Stack, port int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error) {
	rsp, err := c.DeleteOutboundportWithBody(ctx, stack, port, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundportResponse(rsp)
}

func (c *ClientWithResponses) DeleteOutboundportWithResponse(ctx context.Context, stack Stack, port int32, body DeleteOutboundportJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOutboundportResponse, error) {
	rsp, err := c.DeleteOutboundport(ctx, stack, port, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutboundportResponse(rsp)
}

// DescribeOutboundportsWithResponse request returning *DescribeOutboundportsResponse
func (c *ClientWithResponses) DescribeOutboundportsWithResponse(ctx context.Context, stack Stack, port int32, reqEditors ...RequestEditorFn) (*DescribeOutboundportsResponse, error) {
	rsp, err := c.DescribeOutboundports(ctx, stack, port, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeOutboundportsResponse(rsp)
}

// DeleteSubnetsWithBodyWithResponse request with arbitrary body returning *DeleteSubnetsResponse
func (c *ClientWithResponses) DeleteSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error) {
	rsp, err := c.DeleteSubnetsWithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetsResponse(rsp)
}

func (c *ClientWithResponses) DeleteSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSubnetsResponse, error) {
	rsp, err := c.DeleteSubnets(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetsResponse(rsp)
}

// DescribeAllowlistWithResponse request returning *DescribeAllowlistResponse
func (c *ClientWithResponses) DescribeAllowlistWithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistResponse, error) {
	rsp, err := c.DescribeAllowlist(ctx, stack, feature, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAllowlistResponse(rsp)
}

// AddSubnetsWithBodyWithResponse request with arbitrary body returning *AddSubnetsResponse
func (c *ClientWithResponses) AddSubnetsWithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error) {
	rsp, err := c.AddSubnetsWithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubnetsResponse(rsp)
}

func (c *ClientWithResponses) AddSubnetsWithResponse(ctx context.Context, stack Stack, feature Feature, body AddSubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubnetsResponse, error) {
	rsp, err := c.AddSubnets(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubnetsResponse(rsp)
}

// DeleteAllowlistsV6WithBodyWithResponse request with arbitrary body returning *DeleteAllowlistsV6Response
func (c *ClientWithResponses) DeleteAllowlistsV6WithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAllowlistsV6Response, error) {
	rsp, err := c.DeleteAllowlistsV6WithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowlistsV6Response(rsp)
}

func (c *ClientWithResponses) DeleteAllowlistsV6WithResponse(ctx context.Context, stack Stack, feature Feature, body DeleteAllowlistsV6JSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAllowlistsV6Response, error) {
	rsp, err := c.DeleteAllowlistsV6(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowlistsV6Response(rsp)
}

// DescribeAllowlistV6WithResponse request returning *DescribeAllowlistV6Response
func (c *ClientWithResponses) DescribeAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, reqEditors ...RequestEditorFn) (*DescribeAllowlistV6Response, error) {
	rsp, err := c.DescribeAllowlistV6(ctx, stack, feature, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAllowlistV6Response(rsp)
}

// CreateAllowlistV6WithBodyWithResponse request with arbitrary body returning *CreateAllowlistV6Response
func (c *ClientWithResponses) CreateAllowlistV6WithBodyWithResponse(ctx context.Context, stack Stack, feature Feature, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAllowlistV6Response, error) {
	rsp, err := c.CreateAllowlistV6WithBody(ctx, stack, feature, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllowlistV6Response(rsp)
}

func (c *ClientWithResponses) CreateAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, body CreateAllowlistV6JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAllowlistV6Response, error) {
	rsp, err := c.CreateAllowlistV6(ctx, stack, feature, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAllowlistV6Response(rsp)
}

// DeleteAllowlistV6WithResponse request returning *DeleteAllowlistV6Response
func (c *ClientWithResponses) DeleteAllowlistV6WithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteAllowlistV6Response, error) {
	rsp, err := c.DeleteAllowlistV6(ctx, stack, feature, subnet, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllowlistV6Response(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, stack Stack, feature Feature, subnet string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, stack, feature, subnet, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, stack Stack, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// InstallAppWithBodyWithResponse request with arbitrary body returning *InstallAppResponse
func (c *ClientWithResponses) InstallAppWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppResponse, error) {
	rsp, err := c.InstallAppWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAppResponse(rsp)
}

// ListAppsVictoriaWithResponse request returning *ListAppsVictoriaResponse
func (c *ClientWithResponses) ListAppsVictoriaWithResponse(ctx context.Context, stack Stack, params *ListAppsVictoriaParams, reqEditors ...RequestEditorFn) (*ListAppsVictoriaResponse, error) {
	rsp, err := c.ListAppsVictoria(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsVictoriaResponse(rsp)
}

// InstallAppVictoriaWithBodyWithResponse request with arbitrary body returning *InstallAppVictoriaResponse
func (c *ClientWithResponses) InstallAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, params *InstallAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallAppVictoriaResponse, error) {
	rsp, err := c.InstallAppVictoriaWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAppVictoriaResponse(rsp)
}

// DownloadAppExportVictoriaWithResponse request returning *DownloadAppExportVictoriaResponse
func (c *ClientWithResponses) DownloadAppExportVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, params *DownloadAppExportVictoriaParams, reqEditors ...RequestEditorFn) (*DownloadAppExportVictoriaResponse, error) {
	rsp, err := c.DownloadAppExportVictoria(ctx, stack, app, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAppExportVictoriaResponse(rsp)
}

// UninstallAppVictoriaWithResponse request returning *UninstallAppVictoriaResponse
func (c *ClientWithResponses) UninstallAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppVictoriaResponse, error) {
	rsp, err := c.UninstallAppVictoria(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppVictoriaResponse(rsp)
}

// DescribeAppVictoriaWithResponse request returning *DescribeAppVictoriaResponse
func (c *ClientWithResponses) DescribeAppVictoriaWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppVictoriaResponse, error) {
	rsp, err := c.DescribeAppVictoria(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppVictoriaResponse(rsp)
}

// PatchAppVictoriaWithBodyWithResponse request with arbitrary body returning *PatchAppVictoriaResponse
func (c *ClientWithResponses) PatchAppVictoriaWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppVictoriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppVictoriaResponse, error) {
	rsp, err := c.PatchAppVictoriaWithBody(ctx, stack, app, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppVictoriaResponse(rsp)
}

// UninstallAppWithResponse request returning *UninstallAppResponse
func (c *ClientWithResponses) UninstallAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*UninstallAppResponse, error) {
	rsp, err := c.UninstallApp(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAppResponse(rsp)
}

// DescribeAppWithResponse request returning *DescribeAppResponse
func (c *ClientWithResponses) DescribeAppWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribeAppResponse, error) {
	rsp, err := c.DescribeApp(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppResponse(rsp)
}

// PatchAppClassicWithBodyWithResponse request with arbitrary body returning *PatchAppClassicResponse
func (c *ClientWithResponses) PatchAppClassicWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, params *PatchAppClassicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppClassicResponse, error) {
	rsp, err := c.PatchAppClassicWithBody(ctx, stack, app, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppClassicResponse(rsp)
}

// ListCapabilitiesWithResponse request returning *ListCapabilitiesResponse
func (c *ClientWithResponses) ListCapabilitiesWithResponse(ctx context.Context, stack Stack, params *ListCapabilitiesParams, reqEditors ...RequestEditorFn) (*ListCapabilitiesResponse, error) {
	rsp, err := c.ListCapabilities(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCapabilitiesResponse(rsp)
}

// DescribeManagedGlueResourcesWithResponse request returning *DescribeManagedGlueResourcesResponse
func (c *ClientWithResponses) DescribeManagedGlueResourcesWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeManagedGlueResourcesResponse, error) {
	rsp, err := c.DescribeManagedGlueResources(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeManagedGlueResourcesResponse(rsp)
}

// UpdateManagedGlueResourcesWithBodyWithResponse request with arbitrary body returning *UpdateManagedGlueResourcesResponse
func (c *ClientWithResponses) UpdateManagedGlueResourcesWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManagedGlueResourcesResponse, error) {
	rsp, err := c.UpdateManagedGlueResourcesWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManagedGlueResourcesResponse(rsp)
}

func (c *ClientWithResponses) UpdateManagedGlueResourcesWithResponse(ctx context.Context, stack Stack, body UpdateManagedGlueResourcesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManagedGlueResourcesResponse, error) {
	rsp, err := c.UpdateManagedGlueResources(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManagedGlueResourcesResponse(rsp)
}

// ListSelfStorageLocationsWithResponse request returning *ListSelfStorageLocationsResponse
func (c *ClientWithResponses) ListSelfStorageLocationsWithResponse(ctx context.Context, stack Stack, params *ListSelfStorageLocationsParams, reqEditors ...RequestEditorFn) (*ListSelfStorageLocationsResponse, error) {
	rsp, err := c.ListSelfStorageLocations(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSelfStorageLocationsResponse(rsp)
}

// CreateSelfStorageLocationWithBodyWithResponse request with arbitrary body returning *CreateSelfStorageLocationResponse
func (c *ClientWithResponses) CreateSelfStorageLocationWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error) {
	rsp, err := c.CreateSelfStorageLocationWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfStorageLocationResponse(rsp)
}

func (c *ClientWithResponses) CreateSelfStorageLocationWithResponse(ctx context.Context, stack Stack, body CreateSelfStorageLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSelfStorageLocationResponse, error) {
	rsp, err := c.CreateSelfStorageLocation(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSelfStorageLocationResponse(rsp)
}

// GetSelfStorageLocationPolicyWithResponse request returning *GetSelfStorageLocationPolicyResponse
func (c *ClientWithResponses) GetSelfStorageLocationPolicyWithResponse(ctx context.Context, stack Stack, bucketName BucketName, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPolicyResponse, error) {
	rsp, err := c.GetSelfStorageLocationPolicy(ctx, stack, bucketName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationPolicyResponse(rsp)
}

// DescribeSelfStorageLocationWithResponse request returning *DescribeSelfStorageLocationResponse
func (c *ClientWithResponses) DescribeSelfStorageLocationWithResponse(ctx context.Context, stack Stack, bucketPath BucketPath, reqEditors ...RequestEditorFn) (*DescribeSelfStorageLocationResponse, error) {
	rsp, err := c.DescribeSelfStorageLocation(ctx, stack, bucketPath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeSelfStorageLocationResponse(rsp)
}

// GetSelfStorageLocationPrefixWithResponse request returning *GetSelfStorageLocationPrefixResponse
func (c *ClientWithResponses) GetSelfStorageLocationPrefixWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationPrefixResponse, error) {
	rsp, err := c.GetSelfStorageLocationPrefix(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationPrefixResponse(rsp)
}

// GetSelfStorageLocationServiceAccountsWithResponse request returning *GetSelfStorageLocationServiceAccountsResponse
func (c *ClientWithResponses) GetSelfStorageLocationServiceAccountsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetSelfStorageLocationServiceAccountsResponse, error) {
	rsp, err := c.GetSelfStorageLocationServiceAccounts(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfStorageLocationServiceAccountsResponse(rsp)
}

// RetryDeploymentWithResponse request returning *RetryDeploymentResponse
func (c *ClientWithResponses) RetryDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RetryDeploymentResponse, error) {
	rsp, err := c.RetryDeployment(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetryDeploymentResponse(rsp)
}

// ListDeploymentWithResponse request returning *ListDeploymentResponse
func (c *ClientWithResponses) ListDeploymentWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ListDeploymentResponse, error) {
	rsp, err := c.ListDeployment(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentResponse(rsp)
}

// DescribeDeploymentWithResponse request returning *DescribeDeploymentResponse
func (c *ClientWithResponses) DescribeDeploymentWithResponse(ctx context.Context, stack Stack, deploymentID DeploymentID, reqEditors ...RequestEditorFn) (*DescribeDeploymentResponse, error) {
	rsp, err := c.DescribeDeployment(ctx, stack, deploymentID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeDeploymentResponse(rsp)
}

// PutEmekKeyWithBodyWithResponse request with arbitrary body returning *PutEmekKeyResponse
func (c *ClientWithResponses) PutEmekKeyWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEmekKeyResponse, error) {
	rsp, err := c.PutEmekKeyWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEmekKeyResponse(rsp)
}

func (c *ClientWithResponses) PutEmekKeyWithResponse(ctx context.Context, stack Stack, body PutEmekKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEmekKeyResponse, error) {
	rsp, err := c.PutEmekKey(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEmekKeyResponse(rsp)
}

// GetEmekPolicyWithResponse request returning *GetEmekPolicyResponse
func (c *ClientWithResponses) GetEmekPolicyWithResponse(ctx context.Context, stack Stack, params *GetEmekPolicyParams, reqEditors ...RequestEditorFn) (*GetEmekPolicyResponse, error) {
	rsp, err := c.GetEmekPolicy(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmekPolicyResponse(rsp)
}

// DescribeEmekWaiverWithResponse request returning *DescribeEmekWaiverResponse
func (c *ClientWithResponses) DescribeEmekWaiverWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeEmekWaiverResponse, error) {
	rsp, err := c.DescribeEmekWaiver(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeEmekWaiverResponse(rsp)
}

// DescribeAppFeatureEnablementWithResponse request returning *DescribeAppFeatureEnablementResponse
func (c *ClientWithResponses) DescribeAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, reqEditors ...RequestEditorFn) (*DescribeAppFeatureEnablementResponse, error) {
	rsp, err := c.DescribeAppFeatureEnablement(ctx, stack, appGroup, featureName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeAppFeatureEnablementResponse(rsp)
}

// SetAppFeatureEnablementWithBodyWithResponse request with arbitrary body returning *SetAppFeatureEnablementResponse
func (c *ClientWithResponses) SetAppFeatureEnablementWithBodyWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error) {
	rsp, err := c.SetAppFeatureEnablementWithBody(ctx, stack, appGroup, featureName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppFeatureEnablementResponse(rsp)
}

func (c *ClientWithResponses) SetAppFeatureEnablementWithResponse(ctx context.Context, stack Stack, appGroup AppGroup, featureName FeatureName, body SetAppFeatureEnablementJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppFeatureEnablementResponse, error) {
	rsp, err := c.SetAppFeatureEnablement(ctx, stack, appGroup, featureName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppFeatureEnablementResponse(rsp)
}

// ListIndexesWithResponse request returning *ListIndexesResponse
func (c *ClientWithResponses) ListIndexesWithResponse(ctx context.Context, stack Stack, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error) {
	rsp, err := c.ListIndexes(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexesResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, stack Stack, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// DeleteIndexWithBodyWithResponse request with arbitrary body returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndexWithBody(ctx, stack, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, stack Stack, index Index, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, stack, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// GetIndexInfoWithResponse request returning *GetIndexInfoResponse
func (c *ClientWithResponses) GetIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, reqEditors ...RequestEditorFn) (*GetIndexInfoResponse, error) {
	rsp, err := c.GetIndexInfo(ctx, stack, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexInfoResponse(rsp)
}

// PatchIndexInfoWithBodyWithResponse request with arbitrary body returning *PatchIndexInfoResponse
func (c *ClientWithResponses) PatchIndexInfoWithBodyWithResponse(ctx context.Context, stack Stack, index Index, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error) {
	rsp, err := c.PatchIndexInfoWithBody(ctx, stack, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchIndexInfoResponse(rsp)
}

func (c *ClientWithResponses) PatchIndexInfoWithResponse(ctx context.Context, stack Stack, index Index, body PatchIndexInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchIndexInfoResponse, error) {
	rsp, err := c.PatchIndexInfo(ctx, stack, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchIndexInfoResponse(rsp)
}

// ListHECsWithResponse request returning *ListHECsResponse
func (c *ClientWithResponses) ListHECsWithResponse(ctx context.Context, stack Stack, params *ListHECsParams, reqEditors ...RequestEditorFn) (*ListHECsResponse, error) {
	rsp, err := c.ListHECs(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHECsResponse(rsp)
}

// CreateHECWithBodyWithResponse request with arbitrary body returning *CreateHECResponse
func (c *ClientWithResponses) CreateHECWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHECResponse, error) {
	rsp, err := c.CreateHECWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHECResponse(rsp)
}

func (c *ClientWithResponses) CreateHECWithResponse(ctx context.Context, stack Stack, body CreateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHECResponse, error) {
	rsp, err := c.CreateHEC(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHECResponse(rsp)
}

// DeleteHecWithBodyWithResponse request with arbitrary body returning *DeleteHecResponse
func (c *ClientWithResponses) DeleteHecWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error) {
	rsp, err := c.DeleteHecWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHecResponse(rsp)
}

func (c *ClientWithResponses) DeleteHecWithResponse(ctx context.Context, stack Stack, hec Hec, body DeleteHecJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHecResponse, error) {
	rsp, err := c.DeleteHec(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHecResponse(rsp)
}

// DescribeHecWithResponse request returning *DescribeHecResponse
func (c *ClientWithResponses) DescribeHecWithResponse(ctx context.Context, stack Stack, hec Hec, reqEditors ...RequestEditorFn) (*DescribeHecResponse, error) {
	rsp, err := c.DescribeHec(ctx, stack, hec, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeHecResponse(rsp)
}

// PatchHECWithBodyWithResponse request with arbitrary body returning *PatchHECResponse
func (c *ClientWithResponses) PatchHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchHECResponse, error) {
	rsp, err := c.PatchHECWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchHECResponse(rsp)
}

func (c *ClientWithResponses) PatchHECWithResponse(ctx context.Context, stack Stack, hec Hec, body PatchHECJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchHECResponse, error) {
	rsp, err := c.PatchHEC(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchHECResponse(rsp)
}

// UpdateHECWithBodyWithResponse request with arbitrary body returning *UpdateHECResponse
func (c *ClientWithResponses) UpdateHECWithBodyWithResponse(ctx context.Context, stack Stack, hec Hec, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error) {
	rsp, err := c.UpdateHECWithBody(ctx, stack, hec, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHECResponse(rsp)
}

func (c *ClientWithResponses) UpdateHECWithResponse(ctx context.Context, stack Stack, hec Hec, body UpdateHECJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHECResponse, error) {
	rsp, err := c.UpdateHEC(ctx, stack, hec, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHECResponse(rsp)
}

// GetAllLimitsConfigWithResponse request returning *GetAllLimitsConfigResponse
func (c *ClientWithResponses) GetAllLimitsConfigWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigResponse, error) {
	rsp, err := c.GetAllLimitsConfig(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLimitsConfigResponse(rsp)
}

// GetAllLimitsConfigDefaultsWithResponse request returning *GetAllLimitsConfigDefaultsResponse
func (c *ClientWithResponses) GetAllLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetAllLimitsConfigDefaultsResponse, error) {
	rsp, err := c.GetAllLimitsConfigDefaults(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLimitsConfigDefaultsResponse(rsp)
}

// GetLimitConfigWithResponse request returning *GetLimitConfigResponse
func (c *ClientWithResponses) GetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitConfigResponse, error) {
	rsp, err := c.GetLimitConfig(ctx, stack, stanza, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitConfigResponse(rsp)
}

// AddLimitConfigWithBodyWithResponse request with arbitrary body returning *AddLimitConfigResponse
func (c *ClientWithResponses) AddLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error) {
	rsp, err := c.AddLimitConfigWithBody(ctx, stack, stanza, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLimitConfigResponse(rsp)
}

func (c *ClientWithResponses) AddLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body AddLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*AddLimitConfigResponse, error) {
	rsp, err := c.AddLimitConfig(ctx, stack, stanza, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddLimitConfigResponse(rsp)
}

// GetLimitsConfigDefaultsWithResponse request returning *GetLimitsConfigDefaultsResponse
func (c *ClientWithResponses) GetLimitsConfigDefaultsWithResponse(ctx context.Context, stack Stack, stanza Stanza, reqEditors ...RequestEditorFn) (*GetLimitsConfigDefaultsResponse, error) {
	rsp, err := c.GetLimitsConfigDefaults(ctx, stack, stanza, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsConfigDefaultsResponse(rsp)
}

// ResetLimitConfigWithBodyWithResponse request with arbitrary body returning *ResetLimitConfigResponse
func (c *ClientWithResponses) ResetLimitConfigWithBodyWithResponse(ctx context.Context, stack Stack, stanza Stanza, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error) {
	rsp, err := c.ResetLimitConfigWithBody(ctx, stack, stanza, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetLimitConfigResponse(rsp)
}

func (c *ClientWithResponses) ResetLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, body ResetLimitConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetLimitConfigResponse, error) {
	rsp, err := c.ResetLimitConfig(ctx, stack, stanza, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetLimitConfigResponse(rsp)
}

// GetKeyLimitConfigWithResponse request returning *GetKeyLimitConfigResponse
func (c *ClientWithResponses) GetKeyLimitConfigWithResponse(ctx context.Context, stack Stack, stanza Stanza, key Key, reqEditors ...RequestEditorFn) (*GetKeyLimitConfigResponse, error) {
	rsp, err := c.GetKeyLimitConfig(ctx, stack, stanza, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyLimitConfigResponse(rsp)
}

// DescribeMaintenanceWindowsPreferencesWithResponse request returning *DescribeMaintenanceWindowsPreferencesResponse
func (c *ClientWithResponses) DescribeMaintenanceWindowsPreferencesWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsPreferencesResponse, error) {
	rsp, err := c.DescribeMaintenanceWindowsPreferences(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeMaintenanceWindowsPreferencesResponse(rsp)
}

// UpdateMaintenanceWindowsPreferencesWithBodyWithResponse request with arbitrary body returning *UpdateMaintenanceWindowsPreferencesResponse
func (c *ClientWithResponses) UpdateMaintenanceWindowsPreferencesWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMaintenanceWindowsPreferencesResponse, error) {
	rsp, err := c.UpdateMaintenanceWindowsPreferencesWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMaintenanceWindowsPreferencesResponse(rsp)
}

func (c *ClientWithResponses) UpdateMaintenanceWindowsPreferencesWithResponse(ctx context.Context, stack Stack, body UpdateMaintenanceWindowsPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMaintenanceWindowsPreferencesResponse, error) {
	rsp, err := c.UpdateMaintenanceWindowsPreferences(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMaintenanceWindowsPreferencesResponse(rsp)
}

// ListMaintenanceWindowsSchedulesWithResponse request returning *ListMaintenanceWindowsSchedulesResponse
func (c *ClientWithResponses) ListMaintenanceWindowsSchedulesWithResponse(ctx context.Context, stack Stack, params *ListMaintenanceWindowsSchedulesParams, reqEditors ...RequestEditorFn) (*ListMaintenanceWindowsSchedulesResponse, error) {
	rsp, err := c.ListMaintenanceWindowsSchedules(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMaintenanceWindowsSchedulesResponse(rsp)
}

// DescribeMaintenanceWindowsScheduleWithResponse request returning *DescribeMaintenanceWindowsScheduleResponse
func (c *ClientWithResponses) DescribeMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DescribeMaintenanceWindowsScheduleResponse, error) {
	rsp, err := c.DescribeMaintenanceWindowsSchedule(ctx, stack, scheduleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeMaintenanceWindowsScheduleResponse(rsp)
}

// AuditMaintenanceWindowsScheduleWithResponse request returning *AuditMaintenanceWindowsScheduleResponse
func (c *ClientWithResponses) AuditMaintenanceWindowsScheduleWithResponse(ctx context.Context, stack Stack, scheduleID ScheduleID, params *AuditMaintenanceWindowsScheduleParams, reqEditors ...RequestEditorFn) (*AuditMaintenanceWindowsScheduleResponse, error) {
	rsp, err := c.AuditMaintenanceWindowsSchedule(ctx, stack, scheduleID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditMaintenanceWindowsScheduleResponse(rsp)
}

// PostObservabilityCapabilitiesOnSplunkWithResponse request returning *PostObservabilityCapabilitiesOnSplunkResponse
func (c *ClientWithResponses) PostObservabilityCapabilitiesOnSplunkWithResponse(ctx context.Context, stack string, reqEditors ...RequestEditorFn) (*PostObservabilityCapabilitiesOnSplunkResponse, error) {
	rsp, err := c.PostObservabilityCapabilitiesOnSplunk(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostObservabilityCapabilitiesOnSplunkResponse(rsp)
}

// EnableRbacOnO11yWithResponse request returning *EnableRbacOnO11yResponse
func (c *ClientWithResponses) EnableRbacOnO11yWithResponse(ctx context.Context, stack string, params *EnableRbacOnO11yParams, reqEditors ...RequestEditorFn) (*EnableRbacOnO11yResponse, error) {
	rsp, err := c.EnableRbacOnO11y(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableRbacOnO11yResponse(rsp)
}

// PostObservabilityPairingWithResponse request returning *PostObservabilityPairingResponse
func (c *ClientWithResponses) PostObservabilityPairingWithResponse(ctx context.Context, stack string, params *PostObservabilityPairingParams, reqEditors ...RequestEditorFn) (*PostObservabilityPairingResponse, error) {
	rsp, err := c.PostObservabilityPairing(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostObservabilityPairingResponse(rsp)
}

// GetObservabilityPairingStatusWithResponse request returning *GetObservabilityPairingStatusResponse
func (c *ClientWithResponses) GetObservabilityPairingStatusWithResponse(ctx context.Context, stack string, pairingId string, params *GetObservabilityPairingStatusParams, reqEditors ...RequestEditorFn) (*GetObservabilityPairingStatusResponse, error) {
	rsp, err := c.GetObservabilityPairingStatus(ctx, stack, pairingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObservabilityPairingStatusResponse(rsp)
}

// ListPermissionsAppsWithResponse request returning *ListPermissionsAppsResponse
func (c *ClientWithResponses) ListPermissionsAppsWithResponse(ctx context.Context, stack Stack, params *ListPermissionsAppsParams, reqEditors ...RequestEditorFn) (*ListPermissionsAppsResponse, error) {
	rsp, err := c.ListPermissionsApps(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsAppsResponse(rsp)
}

// DescribePermissionsAppsWithResponse request returning *DescribePermissionsAppsResponse
func (c *ClientWithResponses) DescribePermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, reqEditors ...RequestEditorFn) (*DescribePermissionsAppsResponse, error) {
	rsp, err := c.DescribePermissionsApps(ctx, stack, app, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribePermissionsAppsResponse(rsp)
}

// PatchPermissionsAppsWithBodyWithResponse request with arbitrary body returning *PatchPermissionsAppsResponse
func (c *ClientWithResponses) PatchPermissionsAppsWithBodyWithResponse(ctx context.Context, stack Stack, app AppName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error) {
	rsp, err := c.PatchPermissionsAppsWithBody(ctx, stack, app, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPermissionsAppsResponse(rsp)
}

func (c *ClientWithResponses) PatchPermissionsAppsWithResponse(ctx context.Context, stack Stack, app AppName, body PatchPermissionsAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPermissionsAppsResponse, error) {
	rsp, err := c.PatchPermissionsApps(ctx, stack, app, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPermissionsAppsResponse(rsp)
}

// ValidatePrivateConnectivityWithResponse request returning *ValidatePrivateConnectivityResponse
func (c *ClientWithResponses) ValidatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*ValidatePrivateConnectivityResponse, error) {
	rsp, err := c.ValidatePrivateConnectivity(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePrivateConnectivityResponse(rsp)
}

// DescribePrivateConnectivityWithResponse request returning *DescribePrivateConnectivityResponse
func (c *ClientWithResponses) DescribePrivateConnectivityWithResponse(ctx context.Context, stack Stack, params *DescribePrivateConnectivityParams, reqEditors ...RequestEditorFn) (*DescribePrivateConnectivityResponse, error) {
	rsp, err := c.DescribePrivateConnectivity(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribePrivateConnectivityResponse(rsp)
}

// UpdatePrivateConnectivityWithBodyWithResponse request with arbitrary body returning *UpdatePrivateConnectivityResponse
func (c *ClientWithResponses) UpdatePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error) {
	rsp, err := c.UpdatePrivateConnectivityWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateConnectivityResponse(rsp)
}

func (c *ClientWithResponses) UpdatePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body UpdatePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePrivateConnectivityResponse, error) {
	rsp, err := c.UpdatePrivateConnectivity(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePrivateConnectivityResponse(rsp)
}

// EnablePrivateConnectivityWithBodyWithResponse request with arbitrary body returning *EnablePrivateConnectivityResponse
func (c *ClientWithResponses) EnablePrivateConnectivityWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error) {
	rsp, err := c.EnablePrivateConnectivityWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePrivateConnectivityResponse(rsp)
}

func (c *ClientWithResponses) EnablePrivateConnectivityWithResponse(ctx context.Context, stack Stack, body EnablePrivateConnectivityJSONRequestBody, reqEditors ...RequestEditorFn) (*EnablePrivateConnectivityResponse, error) {
	rsp, err := c.EnablePrivateConnectivity(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePrivateConnectivityResponse(rsp)
}

// GetPythonVersionWithResponse request returning *GetPythonVersionResponse
func (c *ClientWithResponses) GetPythonVersionWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*GetPythonVersionResponse, error) {
	rsp, err := c.GetPythonVersion(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPythonVersionResponse(rsp)
}

// ChangePythonVersionWithBodyWithResponse request with arbitrary body returning *ChangePythonVersionResponse
func (c *ClientWithResponses) ChangePythonVersionWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePythonVersionResponse, error) {
	rsp, err := c.ChangePythonVersionWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePythonVersionResponse(rsp)
}

func (c *ClientWithResponses) ChangePythonVersionWithResponse(ctx context.Context, stack Stack, body ChangePythonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePythonVersionResponse, error) {
	rsp, err := c.ChangePythonVersion(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePythonVersionResponse(rsp)
}

// RestartStackWithResponse request returning *RestartStackResponse
func (c *ClientWithResponses) RestartStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStackResponse, error) {
	rsp, err := c.RestartStack(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartStackResponse(rsp)
}

// RestartStatusWithResponse request returning *RestartStatusResponse
func (c *ClientWithResponses) RestartStatusWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*RestartStatusResponse, error) {
	rsp, err := c.RestartStatus(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartStatusResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, stack Stack, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, stack Stack, params *CreateRoleParams, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, stack, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, stack, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// DescribeRoleWithResponse request returning *DescribeRoleResponse
func (c *ClientWithResponses) DescribeRoleWithResponse(ctx context.Context, stack Stack, roleName RoleName, reqEditors ...RequestEditorFn) (*DescribeRoleResponse, error) {
	rsp, err := c.DescribeRole(ctx, stack, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeRoleResponse(rsp)
}

// PatchRoleInfoWithBodyWithResponse request with arbitrary body returning *PatchRoleInfoResponse
func (c *ClientWithResponses) PatchRoleInfoWithBodyWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error) {
	rsp, err := c.PatchRoleInfoWithBody(ctx, stack, roleName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleInfoResponse(rsp)
}

func (c *ClientWithResponses) PatchRoleInfoWithResponse(ctx context.Context, stack Stack, roleName RoleName, params *PatchRoleInfoParams, body PatchRoleInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoleInfoResponse, error) {
	rsp, err := c.PatchRoleInfo(ctx, stack, roleName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoleInfoResponse(rsp)
}

// DescribeStackWithResponse request returning *DescribeStackResponse
func (c *ClientWithResponses) DescribeStackWithResponse(ctx context.Context, stack Stack, reqEditors ...RequestEditorFn) (*DescribeStackResponse, error) {
	rsp, err := c.DescribeStack(ctx, stack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeStackResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, stack Stack, params *ListTokensParams, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, stack Stack, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, stack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, stack Stack, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, stack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, stack, tokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetTokenInfoWithResponse request returning *GetTokenInfoResponse
func (c *ClientWithResponses) GetTokenInfoWithResponse(ctx context.Context, stack Stack, tokenID TokenID, reqEditors ...RequestEditorFn) (*GetTokenInfoResponse, error) {
	rsp, err := c.GetTokenInfo(ctx, stack, tokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTokenInfoResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, stack Stack, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, stack, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, stack, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, stack Stack, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, stack, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, stack, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// DescribeUserWithResponse request returning *DescribeUserResponse
func (c *ClientWithResponses) DescribeUserWithResponse(ctx context.Context, stack Stack, userName UserName, reqEditors ...RequestEditorFn) (*DescribeUserResponse, error) {
	rsp, err := c.DescribeUser(ctx, stack, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeUserResponse(rsp)
}

// PatchUserWithBodyWithResponse request with arbitrary body returning *PatchUserResponse
func (c *ClientWithResponses) PatchUserWithBodyWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUserWithBody(ctx, stack, userName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

func (c *ClientWithResponses) PatchUserWithResponse(ctx context.Context, stack Stack, userName UserName, params *PatchUserParams, body PatchUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserResponse, error) {
	rsp, err := c.PatchUser(ctx, stack, userName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserResponse(rsp)
}

// DescribeWorkflowWithResponse request returning *DescribeWorkflowResponse
func (c *ClientWithResponses) DescribeWorkflowWithResponse(ctx context.Context, stack Stack, workflowName WorkflowName, reqEditors ...RequestEditorFn) (*DescribeWorkflowResponse, error) {
	rsp, err := c.DescribeWorkflow(ctx, stack, workflowName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeWorkflowResponse(rsp)
}

// ParseGetOutboundportsResponse parses an HTTP response from a GetOutboundportsWithResponse call
func ParseGetOutboundportsResponse(rsp *http.Response) (*GetOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutboundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddOutboundportsResponse parses an HTTP response from a AddOutboundportsWithResponse call
func ParseAddOutboundportsResponse(rsp *http.Response) (*AddOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListOutboundPortsV6Response parses an HTTP response from a ListOutboundPortsV6WithResponse call
func ParseListOutboundPortsV6Response(rsp *http.Response) (*ListOutboundPortsV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListOutboundPortsV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutboundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOutboundPortsV6Response parses an HTTP response from a CreateOutboundPortsV6WithResponse call
func ParseCreateOutboundPortsV6Response(rsp *http.Response) (*CreateOutboundPortsV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateOutboundPortsV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteOutboundPortV6Response parses an HTTP response from a DeleteOutboundPortV6WithResponse call
func ParseDeleteOutboundPortV6Response(rsp *http.Response) (*DeleteOutboundPortV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutboundPortV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeOutboundportsV6Response parses an HTTP response from a DescribeOutboundportsV6WithResponse call
func ParseDescribeOutboundportsV6Response(rsp *http.Response) (*DescribeOutboundportsV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeOutboundportsV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutboundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteOutboundportResponse parses an HTTP response from a DeleteOutboundportWithResponse call
func ParseDeleteOutboundportResponse(rsp *http.Response) (*DeleteOutboundportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutboundportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeOutboundportsResponse parses an HTTP response from a DescribeOutboundportsWithResponse call
func ParseDescribeOutboundportsResponse(rsp *http.Response) (*DescribeOutboundportsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeOutboundportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OutboundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubnetsResponse parses an HTTP response from a DeleteSubnetsWithResponse call
func ParseDeleteSubnetsResponse(rsp *http.Response) (*DeleteSubnetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAllowlistResponse parses an HTTP response from a DescribeAllowlistWithResponse call
func ParseDescribeAllowlistResponse(rsp *http.Response) (*DescribeAllowlistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAllowlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// the subnets from where the stack feature is accessible from
			Subnets *[]string `json:"subnets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddSubnetsResponse parses an HTTP response from a AddSubnetsWithResponse call
func ParseAddSubnetsResponse(rsp *http.Response) (*AddSubnetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAllowlistsV6Response parses an HTTP response from a DeleteAllowlistsV6WithResponse call
func ParseDeleteAllowlistsV6Response(rsp *http.Response) (*DeleteAllowlistsV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllowlistsV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAllowlistV6Response parses an HTTP response from a DescribeAllowlistV6WithResponse call
func ParseDescribeAllowlistV6Response(rsp *http.Response) (*DescribeAllowlistV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAllowlistV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// the ipv6 subnets from where the stack feature is accessible from
			Subnets *[]string `json:"subnets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAllowlistV6Response parses an HTTP response from a CreateAllowlistV6WithResponse call
func ParseCreateAllowlistV6Response(rsp *http.Response) (*CreateAllowlistV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateAllowlistV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAllowlistV6Response parses an HTTP response from a DeleteAllowlistV6WithResponse call
func ParseDeleteAllowlistV6Response(rsp *http.Response) (*DeleteAllowlistV6Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllowlistV6Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarningResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]App `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInstallAppResponse parses an HTTP response from a InstallAppWithResponse call
func ParseInstallAppResponse(rsp *http.Response) (*InstallAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListAppsVictoriaResponse parses an HTTP response from a ListAppsVictoriaWithResponse call
func ParseListAppsVictoriaResponse(rsp *http.Response) (*ListAppsVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListAppsVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]App `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInstallAppVictoriaResponse parses an HTTP response from a InstallAppVictoriaWithResponse call
func ParseInstallAppVictoriaResponse(rsp *http.Response) (*InstallAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InstallAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDownloadAppExportVictoriaResponse parses an HTTP response from a DownloadAppExportVictoriaWithResponse call
func ParseDownloadAppExportVictoriaResponse(rsp *http.Response) (*DownloadAppExportVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DownloadAppExportVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppVictoriaResponse parses an HTTP response from a UninstallAppVictoriaWithResponse call
func ParseUninstallAppVictoriaResponse(rsp *http.Response) (*UninstallAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppVictoriaResponse parses an HTTP response from a DescribeAppVictoriaWithResponse call
func ParseDescribeAppVictoriaResponse(rsp *http.Response) (*DescribeAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchAppVictoriaResponse parses an HTTP response from a PatchAppVictoriaWithResponse call
func ParsePatchAppVictoriaResponse(rsp *http.Response) (*PatchAppVictoriaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchAppVictoriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUninstallAppResponse parses an HTTP response from a UninstallAppWithResponse call
func ParseUninstallAppResponse(rsp *http.Response) (*UninstallAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UninstallAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppResponse parses an HTTP response from a DescribeAppWithResponse call
func ParseDescribeAppResponse(rsp *http.Response) (*DescribeAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchAppClassicResponse parses an HTTP response from a PatchAppClassicWithResponse call
func ParsePatchAppClassicResponse(rsp *http.Response) (*PatchAppClassicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchAppClassicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCapabilitiesResponse parses an HTTP response from a ListCapabilitiesWithResponse call
func ParseListCapabilitiesResponse(rsp *http.Response) (*ListCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapabilitiesInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeManagedGlueResourcesResponse parses an HTTP response from a DescribeManagedGlueResourcesWithResponse call
func ParseDescribeManagedGlueResourcesResponse(rsp *http.Response) (*DescribeManagedGlueResourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeManagedGlueResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeManagedGlueResources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateManagedGlueResourcesResponse parses an HTTP response from a UpdateManagedGlueResourcesWithResponse call
func ParseUpdateManagedGlueResourcesResponse(rsp *http.Response) (*UpdateManagedGlueResourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateManagedGlueResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListSelfStorageLocationsResponse parses an HTTP response from a ListSelfStorageLocationsWithResponse call
func ParseListSelfStorageLocationsResponse(rsp *http.Response) (*ListSelfStorageLocationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListSelfStorageLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SelfStorageLocations []SelfStorageLocationInfo `json:"selfStorageLocations"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSelfStorageLocationResponse parses an HTTP response from a CreateSelfStorageLocationWithResponse call
func ParseCreateSelfStorageLocationResponse(rsp *http.Response) (*CreateSelfStorageLocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSelfStorageLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SelfStorageLocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationPolicyResponse parses an HTTP response from a GetSelfStorageLocationPolicyWithResponse call
func ParseGetSelfStorageLocationPolicyResponse(rsp *http.Response) (*GetSelfStorageLocationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeSelfStorageLocationResponse parses an HTTP response from a DescribeSelfStorageLocationWithResponse call
func ParseDescribeSelfStorageLocationResponse(rsp *http.Response) (*DescribeSelfStorageLocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeSelfStorageLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationPrefixResponse parses an HTTP response from a GetSelfStorageLocationPrefixWithResponse call
func ParseGetSelfStorageLocationPrefixResponse(rsp *http.Response) (*GetSelfStorageLocationPrefixResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationPrefixResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationPrefix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSelfStorageLocationServiceAccountsResponse parses an HTTP response from a GetSelfStorageLocationServiceAccountsWithResponse call
func ParseGetSelfStorageLocationServiceAccountsResponse(rsp *http.Response) (*GetSelfStorageLocationServiceAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSelfStorageLocationServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelfStorageLocationServiceAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRetryDeploymentResponse parses an HTTP response from a RetryDeploymentWithResponse call
func ParseRetryDeploymentResponse(rsp *http.Response) (*RetryDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RetryDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentInfo `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListDeploymentResponse parses an HTTP response from a ListDeploymentWithResponse call
func ParseListDeploymentResponse(rsp *http.Response) (*ListDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentStatus `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeDeploymentResponse parses an HTTP response from a DescribeDeploymentWithResponse call
func ParseDescribeDeploymentResponse(rsp *http.Response) (*DescribeDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *DeploymentInfo `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutEmekKeyResponse parses an HTTP response from a PutEmekKeyWithResponse call
func ParsePutEmekKeyResponse(rsp *http.Response) (*PutEmekKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutEmekKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EmekKeyUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEmekPolicyResponse parses an HTTP response from a GetEmekPolicyWithResponse call
func ParseGetEmekPolicyResponse(rsp *http.Response) (*GetEmekPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEmekPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmekPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeEmekWaiverResponse parses an HTTP response from a DescribeEmekWaiverWithResponse call
func ParseDescribeEmekWaiverResponse(rsp *http.Response) (*DescribeEmekWaiverResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeEmekWaiverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeAppFeatureEnablementResponse parses an HTTP response from a DescribeAppFeatureEnablementWithResponse call
func ParseDescribeAppFeatureEnablementResponse(rsp *http.Response) (*DescribeAppFeatureEnablementResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeAppFeatureEnablementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppFeatureEnablement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetAppFeatureEnablementResponse parses an HTTP response from a SetAppFeatureEnablementWithResponse call
func ParseSetAppFeatureEnablementResponse(rsp *http.Response) (*SetAppFeatureEnablementResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetAppFeatureEnablementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AppFeatureEnablement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIndexesResponse parses an HTTP response from a ListIndexesWithResponse call
func ParseListIndexesResponse(rsp *http.Response) (*ListIndexesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Indexes *[]IndexResponse `json:"indexes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest IndexInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIndexInfoResponse parses an HTTP response from a GetIndexInfoWithResponse call
func ParseGetIndexInfoResponse(rsp *http.Response) (*GetIndexInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetIndexInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Indexinfo *IndexResponse `json:"indexinfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchIndexInfoResponse parses an HTTP response from a PatchIndexInfoWithResponse call
func ParsePatchIndexInfoResponse(rsp *http.Response) (*PatchIndexInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchIndexInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListHECsResponse parses an HTTP response from a ListHECsWithResponse call
func ParseListHECsResponse(rsp *http.Response) (*ListHECsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListHECsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			HttpEventCollectors *[]HecInfo `json:"http_event_collectors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHECResponse parses an HTTP response from a CreateHECWithResponse call
func ParseCreateHECResponse(rsp *http.Response) (*CreateHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			HttpEventCollector *HecSpec `json:"http-event-collector,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHecResponse parses an HTTP response from a DeleteHecWithResponse call
func ParseDeleteHecResponse(rsp *http.Response) (*DeleteHecResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteHecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeHecResponse parses an HTTP response from a DescribeHecWithResponse call
func ParseDescribeHecResponse(rsp *http.Response) (*DescribeHecResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeHecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			HttpEventCollector *HecInfo `json:"http-event-collector,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchHECResponse parses an HTTP response from a PatchHECWithResponse call
func ParsePatchHECResponse(rsp *http.Response) (*PatchHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateHECResponse parses an HTTP response from a UpdateHECWithResponse call
func ParseUpdateHECResponse(rsp *http.Response) (*UpdateHECResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateHECResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLimitsConfigResponse parses an HTTP response from a GetAllLimitsConfigWithResponse call
func ParseGetAllLimitsConfigResponse(rsp *http.Response) (*GetAllLimitsConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAllLimitsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLimitsConfigDefaultsResponse parses an HTTP response from a GetAllLimitsConfigDefaultsWithResponse call
func ParseGetAllLimitsConfigDefaultsResponse(rsp *http.Response) (*GetAllLimitsConfigDefaultsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAllLimitsConfigDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LimitStanza
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLimitConfigResponse parses an HTTP response from a GetLimitConfigWithResponse call
func ParseGetLimitConfigResponse(rsp *http.Response) (*GetLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddLimitConfigResponse parses an HTTP response from a AddLimitConfigWithResponse call
func ParseAddLimitConfigResponse(rsp *http.Response) (*AddLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLimitsConfigDefaultsResponse parses an HTTP response from a GetLimitsConfigDefaultsWithResponse call
func ParseGetLimitsConfigDefaultsResponse(rsp *http.Response) (*GetLimitsConfigDefaultsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsConfigDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LimitStanza
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetLimitConfigResponse parses an HTTP response from a ResetLimitConfigWithResponse call
func ParseResetLimitConfigResponse(rsp *http.Response) (*ResetLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeyLimitConfigResponse parses an HTTP response from a GetKeyLimitConfigWithResponse call
func ParseGetKeyLimitConfigResponse(rsp *http.Response) (*GetKeyLimitConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetKeyLimitConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Limitconfiguration *LimitConfigurationResponse `json:"limitconfiguration,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeMaintenanceWindowsPreferencesResponse parses an HTTP response from a DescribeMaintenanceWindowsPreferencesWithResponse call
func ParseDescribeMaintenanceWindowsPreferencesResponse(rsp *http.Response) (*DescribeMaintenanceWindowsPreferencesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeMaintenanceWindowsPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceWindowsPreferencesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateMaintenanceWindowsPreferencesResponse parses an HTTP response from a UpdateMaintenanceWindowsPreferencesWithResponse call
func ParseUpdateMaintenanceWindowsPreferencesResponse(rsp *http.Response) (*UpdateMaintenanceWindowsPreferencesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateMaintenanceWindowsPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMaintenanceWindowsSchedulesResponse parses an HTTP response from a ListMaintenanceWindowsSchedulesWithResponse call
func ParseListMaintenanceWindowsSchedulesResponse(rsp *http.Response) (*ListMaintenanceWindowsSchedulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListMaintenanceWindowsSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeMaintenanceWindowsScheduleResponse parses an HTTP response from a DescribeMaintenanceWindowsScheduleWithResponse call
func ParseDescribeMaintenanceWindowsScheduleResponse(rsp *http.Response) (*DescribeMaintenanceWindowsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeMaintenanceWindowsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceWindowsSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAuditMaintenanceWindowsScheduleResponse parses an HTTP response from a AuditMaintenanceWindowsScheduleWithResponse call
func ParseAuditMaintenanceWindowsScheduleResponse(rsp *http.Response) (*AuditMaintenanceWindowsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AuditMaintenanceWindowsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostObservabilityCapabilitiesOnSplunkResponse parses an HTTP response from a PostObservabilityCapabilitiesOnSplunkWithResponse call
func ParsePostObservabilityCapabilitiesOnSplunkResponse(rsp *http.Response) (*PostObservabilityCapabilitiesOnSplunkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostObservabilityCapabilitiesOnSplunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EnableObservabilityCapabilitiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEnableRbacOnO11yResponse parses an HTTP response from a EnableRbacOnO11yWithResponse call
func ParseEnableRbacOnO11yResponse(rsp *http.Response) (*EnableRbacOnO11yResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EnableRbacOnO11yResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostObservabilityPairingResponse parses an HTTP response from a PostObservabilityPairingWithResponse call
func ParsePostObservabilityPairingResponse(rsp *http.Response) (*PostObservabilityPairingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostObservabilityPairingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateEcSsoPairingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetObservabilityPairingStatusResponse parses an HTTP response from a GetObservabilityPairingStatusWithResponse call
func ParseGetObservabilityPairingStatusResponse(rsp *http.Response) (*GetObservabilityPairingStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetObservabilityPairingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEcSsoPairingStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPermissionsAppsResponse parses an HTTP response from a ListPermissionsAppsWithResponse call
func ParseListPermissionsAppsResponse(rsp *http.Response) (*ListPermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *AppPermsList `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribePermissionsAppsResponse parses an HTTP response from a DescribePermissionsAppsWithResponse call
func ParseDescribePermissionsAppsResponse(rsp *http.Response) (*DescribePermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribePermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPerms
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchPermissionsAppsResponse parses an HTTP response from a PatchPermissionsAppsWithResponse call
func ParsePatchPermissionsAppsResponse(rsp *http.Response) (*PatchPermissionsAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchPermissionsAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseValidatePrivateConnectivityResponse parses an HTTP response from a ValidatePrivateConnectivityWithResponse call
func ParseValidatePrivateConnectivityResponse(rsp *http.Response) (*ValidatePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ValidatePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeEligibilityPrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribePrivateConnectivityResponse parses an HTTP response from a DescribePrivateConnectivityWithResponse call
func ParseDescribePrivateConnectivityResponse(rsp *http.Response) (*DescribePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePrivateConnectivityResponse parses an HTTP response from a UpdatePrivateConnectivityWithResponse call
func ParseUpdatePrivateConnectivityResponse(rsp *http.Response) (*UpdatePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdatePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEnablePrivateConnectivityResponse parses an HTTP response from a EnablePrivateConnectivityWithResponse call
func ParseEnablePrivateConnectivityResponse(rsp *http.Response) (*EnablePrivateConnectivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EnablePrivateConnectivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EnablePrivateConnectivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPythonVersionResponse parses an HTTP response from a GetPythonVersionWithResponse call
func ParseGetPythonVersionResponse(rsp *http.Response) (*GetPythonVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPythonVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PythonVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangePythonVersionResponse parses an HTTP response from a ChangePythonVersionWithResponse call
func ParseChangePythonVersionResponse(rsp *http.Response) (*ChangePythonVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ChangePythonVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PythonVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestartStackResponse parses an HTTP response from a RestartStackWithResponse call
func ParseRestartStackResponse(rsp *http.Response) (*RestartStackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestartStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RestartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestartStatusResponse parses an HTTP response from a RestartStatusWithResponse call
func ParseRestartStatusResponse(rsp *http.Response) (*RestartStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestartStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ShcStatus *[]RestartStatus `json:"shcStatus,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Roles *[]RolesResponse `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeRoleResponse parses an HTTP response from a DescribeRoleWithResponse call
func ParseDescribeRoleResponse(rsp *http.Response) (*DescribeRoleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchRoleInfoResponse parses an HTTP response from a PatchRoleInfoWithResponse call
func ParsePatchRoleInfoResponse(rsp *http.Response) (*PatchRoleInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchRoleInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeStackResponse parses an HTTP response from a DescribeStackWithResponse call
func ParseDescribeStackResponse(rsp *http.Response) (*DescribeStackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *StackStatus `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokens *[]TokenInfo `json:"tokens,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTokenInfoResponse parses an HTTP response from a GetTokenInfoWithResponse call
func ParseGetTokenInfoResponse(rsp *http.Response) (*GetTokenInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTokenInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Tokeninfo *TokenInfo `json:"tokeninfo,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Users *[]UsersResponse `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeUserResponse parses an HTTP response from a DescribeUserWithResponse call
func ParseDescribeUserResponse(rsp *http.Response) (*DescribeUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchUserResponse parses an HTTP response from a PatchUserWithResponse call
func ParsePatchUserResponse(rsp *http.Response) (*PatchUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PatchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDescribeWorkflowResponse parses an HTTP response from a DescribeWorkflowWithResponse call
func ParseDescribeWorkflowResponse(rsp *http.Response) (*DescribeWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DescribeWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
